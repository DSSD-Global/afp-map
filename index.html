<head>
  <title>AFP Map</title>

  <link href="https://fonts.googleapis.com/css?family=Cardo:400,700|Oswald" rel="stylesheet">

  <meta charset="utf-8">

  <script>
    document.write('<base href="' + document.location + '" />');
  </script>
  <style>
    /* Add your styles here */
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-size: inherit;
    }

    /** Setting the default font sizes */
    html {
      width: 100%;
      height: 100%;
      background-color: #555566;
    }

    body {
      width: 100%;
      height: 100%;
      cursor: auto;
      background-color: #555566;
    }

    #map {
      height: 100%;
      width: 100%;
      position: absolute;
      top: 0;
      right: 0;
      left: 0;
      bottom: 0;
      z-index: 0;
    }

    .main-icon-footer {
      position: absolute;
      display: flex;
      justify-content: center;
      align-items: center;
      width: 40px;
      height: 40px;
      border-radius: 100%;
      background: white;
      border: 1px #ffffff solid;
      box-shadow: 0px 2px 0px 0px rgb(204, 186, 186);
    }

    .t{
      padding-top: 1px;
      width: 30px;
      height: 30px;
      text-align: right;
    }

    .leaflet-control-layers {
      margin: 10px auto;
      text-align: left;
      overflow: auto;
    }


    /* The sidebar menu */
    .sidebar {
      height: 100%; /* 100% Full-height */
      width: 0; /* 0 width - change this with JavaScript */
      position: absolute; /* Stay in place */
      z-index: 1000; /* Stay on top */
      top: 0;
      left: 0;
      background-color:rgba(255, 255, 255, 0.75);
      overflow-x: hidden; /* Disable horizontal scroll */
      word-wrap: normal;
      padding-top: 50px;
      transition: 0.5s; /* 0.5 second transition effect to slide in the sidebar */
    }

    /* Position and style the close button (top right corner) */
    .sidebar .closebtn {
      position: absolute;
      top: 0;
      right: 20px;
      font-size: 36px;
      color: #2a2a2a;
      text-decoration: none;
    }

    .sidebar .closebtn:hover{
      color: #a9a9a9;
    }

    /* Style page content - use this if you want to push the page content to the right when you open the side navigation */
    #main {
      transition: margin-left .5s; /* If you want a transition effect */
      padding: 20px;
    }

    .org_name {
      font-family: 'Oswald', sans-serif;
      text-transform: uppercase;
      font-size: 1.5vw;
      text-align: center;
      margin: 10px 20px 10px 20px;
    }

    .org_img {
      display: block;
      margin-left: auto;
      margin-right: auto;
    }

    .org_desc {
      font-family: 'Cardo', serif;
      font-size: 1.25vw;
      color: #464646;
      margin: 10px 20px 10px 20px;
    }

    .org_url {
      font-family: 'Cardo', serif;
      font-size: 1.25vw;
      color: #464646;
      margin: 20px 20px 10px 20px;
    }

    .org_url > a {
      font-size: 1.25vw;
    }

    .leaflet-control-search.search-exp {/*expanded*/
      background: #fff;
      border: 2px solid rgba(0,0,0,0.2);
      background-clip: padding-box;
    }
    .leaflet-control-search .search-input {
      display:block;
      float:left;
      background: #fff;
      border:1px solid #666;
      border-radius:2px;
      height:22px;
      padding:0 20px 0 2px;
      margin:4px 0 4px 4px;
    }
    .leaflet-control-search.search-load .search-input {
      background: url('https://raw.githubusercontent.com/stefanocudini/leaflet-search/master/images/loader.gif') no-repeat center right #fff;
    }
    .leaflet-control-search.search-load .search-cancel {
      visibility:hidden;
    }
    .leaflet-control-search .search-cancel {
      display:block;
      width:22px;
      height:22px;
      position:absolute;
      right:28px;
      margin:6px 0;
      background: url('https://raw.githubusercontent.com/stefanocudini/leaflet-search/master/images/search-icon.png') no-repeat 0 -46px;
      text-decoration:none;
      filter: alpha(opacity=80);
      opacity: 0.8;
    }
    .leaflet-control-search .search-cancel:hover {
      filter: alpha(opacity=100);
      opacity: 1;
    }
    .leaflet-control-search .search-cancel span {
      display:none;/* comment for cancel button imageless */
      font-size:18px;
      line-height:20px;
      color:#ccc;
      font-weight:bold;
    }
    .leaflet-control-search .search-cancel:hover span {
      color:#aaa;
    }
    .leaflet-control-search .search-button {
      display:block;
      float:right;
      width:30px;
      height:30px;
      background: url('https://raw.githubusercontent.com/stefanocudini/leaflet-search/master/images/search-icon.png') no-repeat 4px 4px #fff;
      border-right-width: 400px;
      border-radius:400px;
      border-color:red;
    }
    .leaflet-control-search .search-button:hover {
      background: url('https://raw.githubusercontent.com/stefanocudini/leaflet-search/master/images/search-icon.png') no-repeat 4px -20px #fafafa;
    }
    .leaflet-control-search .search-tooltip {
      position:absolute;
      top:100%;
      left:0;
      float:left;
      list-style: none;
      padding-left: 0;
      min-width:120px;
      max-height:122px;
      box-shadow: 1px 1px 6px rgba(0,0,0,0.4);
      background-color: rgba(0, 0, 0, 0.25);
      z-index:1010;
      overflow-y:auto;
      overflow-x:hidden;
      cursor: pointer;
    }
    .leaflet-control-search .search-tip {
      margin:2px;
      padding:2px 4px;
      display:block;
      color:black;
      background: #eee;
      border-radius:.25em;
      text-decoration:none;
      white-space:nowrap;
    }
    .leaflet-control-search .search-button:hover {
      background-color: #f4f4f4;
    }
    .leaflet-control-search .search-tip-select,
    .leaflet-control-search .search-tip:hover {
      background-color: #fff;
    }
    .leaflet-control-search .search-alert {
      cursor:pointer;
      clear:both;
      font-size:.75em;
      margin-bottom:5px;
      padding:0 .25em;
      color:#e00;
      font-weight:bold;
      border-radius:.25em;
    }
  </style>

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.0.3/leaflet.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.0.3/leaflet.js"></script>
  <script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.0.7/angular.min.js"></script>


  <script type="text/javascript">
    /*
     Name          Data passed        Description

     Managed Events:
      search:locationfound {latlng, title, layer} fired after moved and show markerLocation
      search:expanded    {}             fired after control was expanded
      search:collapsed   {}             fired after control was collapsed
       search:cancel     {}             fired after cancel button clicked

     Public methods:
      setLayer()       L.LayerGroup()         set layer search at runtime
      showAlert()            'Text message'         show alert message
      searchText()     'Text searched'        search text by external code
   */

    //TODO implement can do research on multiple sources layers and remote
    //TODO history: false,    //show latest searches in tooltip
    //FIXME option condition problem {autoCollapse: true, markerLocation: true} not show location
    //FIXME option condition problem {autoCollapse: false }
    //
    //TODO here insert function  search inputText FIRST in _recordsCache keys and if not find results..
    //  run one of callbacks search(sourceData,jsonpUrl or options.layer) and run this.showTooltip
    //
    //TODO change structure of _recordsCache
    //  like this: _recordsCache = {"text-key1": {loc:[lat,lng], ..other attributes.. }, {"text-key2": {loc:[lat,lng]}...}, ...}
    //  in this mode every record can have a free structure of attributes, only 'loc' is required
    //TODO important optimization!!! always append data in this._recordsCache
    //  now _recordsCache content is emptied and replaced with new data founded
    //  always appending data on _recordsCache give the possibility of caching ajax, jsonp and layersearch!
    //
    //TODO here insert function  search inputText FIRST in _recordsCache keys and if not find results..
    //  run one of callbacks search(sourceData,jsonpUrl or options.layer) and run this.showTooltip
    //
    //TODO change structure of _recordsCache
    //  like this: _recordsCache = {"text-key1": {loc:[lat,lng], ..other attributes.. }, {"text-key2": {loc:[lat,lng]}...}, ...}
    //  in this way every record can have a free structure of attributes, only 'loc' is required

    (function (factory) {
      if(typeof define === 'function' && define.amd) {
        //AMD
        define(['leaflet'], factory);
      } else if(typeof module !== 'undefined') {
        // Node/CommonJS
        module.exports = factory(require('leaflet'));
      } else {
        // Browser globals
        if(typeof window.L === 'undefined')
          throw 'Leaflet must be loaded first';
        factory(window.L);
      }
    })(function (L) {


      L.Control.Search = L.Control.extend({

        includes: L.version[0]==='1' ? L.Evented.prototype : L.Mixin.Events,

        options: {
          url: '',            //url for search by ajax request, ex: "search.php?q={s}". Can be function to returns string for dynamic parameter setting
          layer: null,          //layer where search markers(is a L.LayerGroup)
          sourceData: null,       //function to fill _recordsCache, passed searching text by first param and callback in second
          //TODO implements uniq option 'sourceData' to recognizes source type: url,array,callback or layer
          jsonpParam: null,       //jsonp param name for search by jsonp service, ex: "callback"
          propertyLoc: 'loc',       //field for remapping location, using array: ['latname','lonname'] for select double fields(ex. ['lat','lon'] ) support dotted format: 'prop.subprop.title'
          propertyName: 'org_title',      //property in marker.options(or feature.properties for vector layer) trough filter elements in layer,
          formatData: null,       //callback for reformat all data from source to indexed data object
          filterData: null,       //callback for filtering data from text searched, params: textSearch, allRecords
          moveToLocation: null,     //callback run on location found, params: latlng, title, map
          buildTip: null,         //function to return row tip html node(or html string), receive text tooltip in first param
          container: '',          //container id to insert Search Control
          zoom: null,           //default zoom level for move to location
          minLength: 1,         //minimal text length for autocomplete
          initial: true,          //search elements only by initial text
          casesensitive: false,     //search elements in case sensitive text
          autoType: true,         //complete input with first suggested result and select this filled-in text.
          delayType: 400,         //delay while typing for show tooltip
          tooltipLimit: -1,       //limit max results to show in tooltip. -1 for no limit, 0 for no results
          tipAutoSubmit: true,      //auto map panTo when click on tooltip
          firstTipSubmit: false,      //auto select first result con enter click
          autoResize: true,       //autoresize on input change
          collapsed: true,        //collapse search control at startup
          autoCollapse: false,      //collapse search control after submit(on button or on tips if enabled tipAutoSubmit)
          autoCollapseTime: 1200,     //delay for autoclosing alert and collapse after blur
          textErr: 'Location not found',  //error message
          textCancel: 'Cancel',       //title in cancel button
          textPlaceholder: 'Search...',   //placeholder value
          hideMarkerOnCollapse: false,    //remove circle and marker on search control collapsed
          position: 'topleft',
          marker: {           //custom L.Marker or false for hide
            icon: false,        //custom L.Icon for maker location or false for hide
            animate: true,        //animate a circle over location found
            circle: {         //draw a circle in location found
              radius: 10,
              weight: 3,
              color: '#e03',
              stroke: true,
              fill: false
            }
          }
        },

        _getPath: function(obj, prop) {
          var parts = prop.split('.'),
                  last = parts.pop(),
                  len = parts.length,
                  cur = parts[0],
                  i = 1;

          if(len > 0)
            while((obj = obj[cur]) && i < len)
              cur = parts[i++];

          if(obj)
            return obj[last];
        },

        _isObject: function(obj) {
          return Object.prototype.toString.call(obj) === "[object Object]";
        },

        initialize: function(options) {
          L.Util.setOptions(this, options || {});
          this._inputMinSize = this.options.textPlaceholder ? this.options.textPlaceholder.length : 10;
          this._layer = this.options.layer || new L.LayerGroup();
          this._filterData = this.options.filterData || this._defaultFilterData;
          this._formatData = this.options.formatData || this._defaultFormatData;
          this._moveToLocation = this.options.moveToLocation || this._defaultMoveToLocation;
          this._autoTypeTmp = this.options.autoType;  //useful for disable autoType temporarily in delete/backspace keydown
          this._countertips = 0;    //number of tips items
          this._recordsCache = {};  //key,value table! to store locations! format: key,latlng
          this._curReq = null;
        },

        onAdd: function (map) {
          this._map = map;
          this._container = L.DomUtil.create('div', 'leaflet-control-search');
          this._input = this._createInput(this.options.textPlaceholder, 'search-input');
          this._tooltip = this._createTooltip('search-tooltip');
          this._cancel = this._createCancel(this.options.textCancel, 'search-cancel');
          this._button = this._createButton(this.options.textPlaceholder, 'search-button');
          this._alert = this._createAlert('search-alert');

          if(this.options.collapsed===false)
            this.expand(this.options.collapsed);

          if(this.options.marker) {

            if(this.options.marker instanceof L.Marker || this.options.marker instanceof L.CircleMarker)
              this._markerSearch = this.options.marker;

            else if(this._isObject(this.options.marker))
              this._markerSearch = new L.Control.Search.Marker([0,0], this.options.marker);

            this._markerSearch._isMarkerSearch = true;
          }

          this.setLayer( this._layer );
          //Figure this out later!
          //L.DomEvent.disableClickPropagation(this);

          map.on({
            //    'layeradd': this._onLayerAddRemove,
            //    'layerremove': this._onLayerAddRemove
            'resize': this._handleAutoresize
          }, this);
          return this._container;
        },
        addTo: function (map) {

          if(this.options.container) {
            this._container = this.onAdd(map);
            this._wrapper = L.DomUtil.get(this.options.container);
            this._wrapper.style.position = 'relative';
            this._wrapper.appendChild(this._container);
          }
          else
            L.Control.prototype.addTo.call(this, map);

          return this;
        },

        onRemove: function(map) {
          this._recordsCache = {};
          // map.off({
          //    'layeradd': this._onLayerAddRemove,
          //    'layerremove': this._onLayerAddRemove
          //  }, this);
          map.off({
            //    'layeradd': this._onLayerAddRemove,
            //    'layerremove': this._onLayerAddRemove
            'resize': this._handleAutoresize
          }, this);
        },

        // _onLayerAddRemove: function(e) {
        //  //without this, run setLayer also for each Markers!! to optimize!
        //  if(e.layer instanceof L.LayerGroup)
        //    if( L.stamp(e.layer) != L.stamp(this._layer) )
        //      this.setLayer(e.layer);
        // },

        setLayer: function(layer) { //set search layer at runtime
          //this.options.layer = layer; //setting this, run only this._recordsFromLayer()
          this._layer = layer;
          this._layer.addTo(this._map);
          return this;
        },

        showAlert: function(text) {
          var self = this;
          text = text || this.options.textErr;
          this._alert.style.display = 'block';
          this._alert.innerHTML = text;
          clearTimeout(this.timerAlert);

          this.timerAlert = setTimeout(function() {
            self.hideAlert();
          },this.options.autoCollapseTime);
          return this;
        },

        hideAlert: function() {
          this._alert.style.display = 'none';
          return this;
        },

        cancel: function() {
          this._input.value = '';
          this._handleKeypress({ keyCode: 8 });//simulate backspace keypress
          this._input.size = this._inputMinSize;
          this._input.focus();
          this._cancel.style.display = 'none';
          this._hideTooltip();
          this.fire('search:cancel');
          return this;
        },

        expand: function(toggle) {
          toggle = typeof toggle === 'boolean' ? toggle : true;
          this._input.style.display = 'block';
          L.DomUtil.addClass(this._container, 'search-exp');
          if ( toggle !== false ) {
            this._input.focus();
            this._map.on('dragstart click', this.collapse, this);
          }
          this.fire('search:expanded');
          return this;
        },

        collapse: function() {
          this._hideTooltip();
          this.cancel();
          this._alert.style.display = 'none';
          this._input.blur();
          if(this.options.collapsed)
          {
            this._input.style.display = 'none';
            this._cancel.style.display = 'none';
            L.DomUtil.removeClass(this._container, 'search-exp');
            if (this.options.hideMarkerOnCollapse) {
              this._map.removeLayer(this._markerSearch);
            }
            this._map.off('dragstart click', this.collapse, this);
          }
          this.fire('search:collapsed');
          return this;
        },

        collapseDelayed: function() { //collapse after delay, used on_input blur
          var self = this;
          if (!this.options.autoCollapse) return this;
          clearTimeout(this.timerCollapse);
          this.timerCollapse = setTimeout(function() {
            self.collapse();
          }, this.options.autoCollapseTime);
          return this;
        },

        collapseDelayedStop: function() {
          clearTimeout(this.timerCollapse);
          return this;
        },

        ////start DOM creations
        _createAlert: function(className) {
          var alert = L.DomUtil.create('div', className, this._container);
          alert.style.display = 'none';

          L.DomEvent
                  .on(alert, 'click', L.DomEvent.stop, this)
                  .on(alert, 'click', this.hideAlert, this);

          return alert;
        },

        _createInput: function (text, className) {
          var self = this;
          var label = L.DomUtil.create('label', className, this._container);
          var input = L.DomUtil.create('input', className, this._container);
          input.type = 'text';
          input.size = this._inputMinSize;
          input.value = '';
          input.autocomplete = 'off';
          input.autocorrect = 'off';
          input.autocapitalize = 'off';
          input.placeholder = text;
          input.style.display = 'none';
          input.role = 'search';
          input.id = input.role + input.type + input.size;

          label.htmlFor = input.id;
          label.style.display = 'none';
          label.value = text;

          L.DomEvent
                  .disableClickPropagation(input)
                  .on(input, 'keyup', this._handleKeypress, this)
                  .on(input, 'paste', function(e) {
                    setTimeout(function(e) {
                      self._handleKeypress(e);
                    },10,e);
                  }, this)
                  .on(input, 'blur', this.collapseDelayed, this)
                  .on(input, 'focus', this.collapseDelayedStop, this);

          return input;
        },

        _createCancel: function (title, className) {
          var cancel = L.DomUtil.create('a', className, this._container);
          cancel.href = '#';
          cancel.title = title;
          cancel.style.display = 'none';
          cancel.innerHTML = "<span>&otimes;</span>";//imageless(see css)

          L.DomEvent
                  .on(cancel, 'click', L.DomEvent.stop, this)
                  .on(cancel, 'click', this.cancel, this);

          return cancel;
        },

        _createButton: function (title, className) {
          var button = L.DomUtil.create('a', className, this._container);
          button.href = '#';
          button.title = title;

          L.DomEvent
                  .on(button, 'click', L.DomEvent.stop, this)
                  .on(button, 'click', this._handleSubmit, this)
                  .on(button, 'focus', this.collapseDelayedStop, this)
                  .on(button, 'blur', this.collapseDelayed, this);

          return button;
        },

        _createTooltip: function(className) {
          var self = this;
          var tool = L.DomUtil.create('ul', className, this._container);
          tool.style.display = 'none';
          L.DomEvent
                  .disableClickPropagation(tool)
                  .on(tool, 'blur', this.collapseDelayed, this)
                  .on(tool, 'mousewheel', function(e) {
                    self.collapseDelayedStop();
                    L.DomEvent.stopPropagation(e);//disable zoom map
                  }, this)
                  .on(tool, 'mouseover', function(e) {
                    self.collapseDelayedStop();
                  }, this);
          return tool;
        },

        _createTip: function(text, val) {//val is object in recordCache, usually is Latlng
          var tip;

          if(this.options.buildTip)
          {
            tip = this.options.buildTip.call(this, text, val); //custom tip node or html string
            if(typeof tip === 'string')
            {
              var tmpNode = L.DomUtil.create('div');
              tmpNode.innerHTML = tip;
              tip = tmpNode.firstChild;
            }
          }
          else
          {
            tip = L.DomUtil.create('li', '');
            tip.innerHTML = text;
          }

          L.DomUtil.addClass(tip, 'search-tip');
          tip._text = text; //value replaced in this._input and used by _autoType

          if(this.options.tipAutoSubmit)
            L.DomEvent
                    .disableClickPropagation(tip)
                    .on(tip, 'click', L.DomEvent.stop, this)
                    .on(tip, 'click', function(e) {
                      this._input.value = text;
                      this._handleAutoresize();
                      this._input.focus();
                      this._hideTooltip();
                      this._handleSubmit();
                    }, this);

          return tip;
        },

        //////end DOM creations

        _getUrl: function(text) {
          return (typeof this.options.url === 'function') ? this.options.url(text) : this.options.url;
        },

        _defaultFilterData: function(text, records) {

          var I, icase, regSearch, frecords = {};

          text = text.replace(/[.*+?^${}()|[\]\\]/g, '');  //sanitize remove all special characters
          if(text==='')
            return [];

          I = this.options.initial ? '^' : '';  //search only initial text
          icase = !this.options.casesensitive ? 'i' : undefined;

          regSearch = new RegExp(I + text, icase);

          //TODO use .filter or .map
          for(var key in records) {
            if( regSearch.test(key) )
              frecords[key]= records[key];
          }

          return frecords;
        },

        showTooltip: function(records) {


          this._countertips = 0;
          this._tooltip.innerHTML = '';
          this._tooltip.currentSelection = -1;  //inizialized for _handleArrowSelect()

          if(this.options.tooltipLimit)
          {
            for(var key in records)//fill tooltip
            {
              if(this._countertips === this.options.tooltipLimit)
                break;

              this._countertips++;

              this._tooltip.appendChild( this._createTip(key, records[key]) );
            }
          }

          if(this._countertips > 0)
          {
            this._tooltip.style.display = 'block';

            if(this._autoTypeTmp)
              this._autoType();

            this._autoTypeTmp = this.options.autoType;//reset default value
          }
          else
            this._hideTooltip();

          this._tooltip.scrollTop = 0;

          return this._countertips;
        },

        _hideTooltip: function() {
          this._tooltip.style.display = 'none';
          this._tooltip.innerHTML = '';
          return 0;
        },

        _defaultFormatData: function(json) {  //default callback for format data to indexed data
          var self = this,
                  propName = this.options.propertyName,
                  propLoc = this.options.propertyLoc,
                  i, jsonret = {};

          if( L.Util.isArray(propLoc) )
            for(i in json)
              jsonret[ self._getPath(json[i],propName) ]= L.latLng( json[i][ propLoc[0] ], json[i][ propLoc[1] ] );
          else
            for(i in json)
              jsonret[ self._getPath(json[i],propName) ]= L.latLng( self._getPath(json[i],propLoc) );
          //TODO throw new Error("propertyName '"+propName+"' not found in JSON data");
          return jsonret;
        },

        _recordsFromJsonp: function(text, callAfter) {  //extract searched records from remote jsonp service
          L.Control.Search.callJsonp = callAfter;
          var script = L.DomUtil.create('script','leaflet-search-jsonp', document.getElementsByTagName('body')[0] ),
                  url = L.Util.template(this._getUrl(text)+'&'+this.options.jsonpParam+'=L.Control.Search.callJsonp', {s: text}); //parsing url
          //rnd = '&_='+Math.floor(Math.random()*10000);
          //TODO add rnd param or randomize callback name! in recordsFromJsonp
          script.type = 'text/javascript';
          script.src = url;
          return { abort: function() { script.parentNode.removeChild(script); } };
        },

        _recordsFromAjax: function(text, callAfter) { //Ajax request
          if (window.XMLHttpRequest === undefined) {
            window.XMLHttpRequest = function() {
              try { return new ActiveXObject("Microsoft.XMLHTTP.6.0"); }
              catch  (e1) {
                try { return new ActiveXObject("Microsoft.XMLHTTP.3.0"); }
                catch (e2) { throw new Error("XMLHttpRequest is not supported"); }
              }
            };
          }
          var IE8or9 = ( L.Browser.ie && !window.atob && document.querySelector ),
                  request = IE8or9 ? new XDomainRequest() : new XMLHttpRequest(),
                  url = L.Util.template(this._getUrl(text), {s: text});

          //rnd = '&_='+Math.floor(Math.random()*10000);
          //TODO add rnd param or randomize callback name! in recordsFromAjax

          request.open("GET", url);


          request.onload = function() {
            callAfter( JSON.parse(request.responseText) );
          };
          request.onreadystatechange = function() {
            if(request.readyState === 4 && request.status === 200) {
              this.onload();
            }
          };

          request.send();
          return request;
        },

        _searchInLayer: function(layer, retRecords, propName) {
          var self = this, loc;

          if(layer instanceof L.Control.Search.Marker) return;

          if(layer instanceof L.Marker || layer instanceof L.CircleMarker)
          {
            if(self._getPath(layer.options,propName))
            {
              loc = layer.getLatLng();
              loc.layer = layer;
              retRecords[ self._getPath(layer.options,propName) ] = loc;
            }
            else if(self._getPath(layer.feature.properties,propName))
            {
              loc = layer.getLatLng();
              loc.layer = layer;
              retRecords[ self._getPath(layer.feature.properties,propName) ] = loc;
            }
            else {
              //throw new Error("propertyName '"+propName+"' not found in marker");
              console.warn("propertyName '"+propName+"' not found in marker");
            }
          }
          else if(layer instanceof L.Path || layer instanceof L.Polyline || layer instanceof L.Polygon)
          {
            if(self._getPath(layer.options,propName))
            {
              loc = layer.getBounds().getCenter();
              loc.layer = layer;
              retRecords[ self._getPath(layer.options,propName) ] = loc;
            }
            else if(self._getPath(layer.feature.properties,propName))
            {
              loc = layer.getBounds().getCenter();
              loc.layer = layer;
              retRecords[ self._getPath(layer.feature.properties,propName) ] = loc;
            }
            else {
              //throw new Error("propertyName '"+propName+"' not found in shape");
              console.warn("propertyName '"+propName+"' not found in shape");
            }
          }
          else if(layer.hasOwnProperty('feature'))//GeoJSON
          {
            if(layer.feature.properties.hasOwnProperty(propName))
            {
              if(layer.getLatLng && typeof layer.getLatLng === 'function') {
                loc = layer.getLatLng();
                loc.layer = layer;
                retRecords[ layer.feature.properties[propName] ] = loc;
              } else if(layer.getBounds && typeof layer.getBounds === 'function') {
                loc = layer.getBounds().getCenter();
                loc.layer = layer;
                retRecords[ layer.feature.properties[propName] ] = loc;
              } else {
                console.warn("Unknown type of Layer");
              }
            }
            else {
              //throw new Error("propertyName '"+propName+"' not found in feature");
              console.warn("propertyName '"+propName+"' not found in feature");
            }
          }
          else if(layer instanceof L.LayerGroup)
          {
            layer.eachLayer(function (layer) {
              self._searchInLayer(layer, retRecords, propName);
            });
          }
        },

        _recordsFromLayer: function() { //return table: key,value from layer
          var self = this,
                  retRecords = {},
                  propName = this.options.propertyName;

          this._layer.eachLayer(function (layer) {
            console.log(layer)
            self._searchInLayer(layer, retRecords, propName);
          });

          return retRecords;
        },

        _autoType: function() {

          //TODO implements autype without selection(useful for mobile device)

          var start = this._input.value.length,
                  firstRecord = this._tooltip.firstChild ? this._tooltip.firstChild._text : '',
                  end = firstRecord.length;

          if (firstRecord.indexOf(this._input.value) === 0) { // If prefix match
            this._input.value = firstRecord;
            this._handleAutoresize();

            if (this._input.createTextRange) {
              var selRange = this._input.createTextRange();
              selRange.collapse(true);
              selRange.moveStart('character', start);
              selRange.moveEnd('character', end);
              selRange.select();
            }
            else if(this._input.setSelectionRange) {
              this._input.setSelectionRange(start, end);
            }
            else if(this._input.selectionStart) {
              this._input.selectionStart = start;
              this._input.selectionEnd = end;
            }
          }
        },

        _hideAutoType: function() { // deselect text:

          var sel;
          if ((sel = this._input.selection) && sel.empty) {
            sel.empty();
          }
          else if (this._input.createTextRange) {
            sel = this._input.createTextRange();
            sel.collapse(true);
            var end = this._input.value.length;
            sel.moveStart('character', end);
            sel.moveEnd('character', end);
            sel.select();
          }
          else {
            if (this._input.getSelection) {
              this._input.getSelection().removeAllRanges();
            }
            this._input.selectionStart = this._input.selectionEnd;
          }
        },

        _handleKeypress: function (e) { //run _input keyup event
          var self = this;

          switch(e.keyCode)
          {
            case 27://Esc
              this.collapse();
              break;
            case 13://Enter
              if(this._countertips == 1 || (this.options.firstTipSubmit && this._countertips > 0)) {
                if(this._tooltip.currentSelection == -1) {
                  this._handleArrowSelect(1);
                }
              }
              this._handleSubmit(); //do search
              break;
            case 38://Up
              this._handleArrowSelect(-1);
              break;
            case 40://Down
              this._handleArrowSelect(1);
              break;
            case 37://Left
            case 39://Right
            case 16://Shift
            case 17://Ctrl
            case 35://End
            case 36://Home
              break;
            case  8://Backspace
            case 45://Insert
            case 46://Delete
              this._autoTypeTmp = false;//disable temporarily autoType
            default://All keys
              if(this._input.value.length)
                this._cancel.style.display = 'block';
              else
                this._cancel.style.display = 'none';

              if(this._input.value.length >= this.options.minLength)
              {
                clearTimeout(this.timerKeypress); //cancel last search request while type in
                this.timerKeypress = setTimeout(function() {  //delay before request, for limit jsonp/ajax request

                  self._fillRecordsCache();

                }, this.options.delayType);
              }
              else
                this._hideTooltip();
          }

          this._handleAutoresize();
        },

        searchText: function(text) {
          var code = text.charCodeAt(text.length);

          this._input.value = text;

          this._input.style.display = 'block';
          L.DomUtil.addClass(this._container, 'search-exp');

          this._autoTypeTmp = false;

          this._handleKeypress({keyCode: code});
        },

        _fillRecordsCache: function() {

          var self = this,
                  inputText = this._input.value, records;

          if(this._curReq && this._curReq.abort)
            this._curReq.abort();
          //abort previous requests

          L.DomUtil.addClass(this._container, 'search-load');

          if(this._layer)
          {
            //TODO _recordsFromLayer must return array of objects, formatted from _formatData
            this._recordsCache = this._recordsFromLayer();

            records = this._filterData( this._input.value, this._recordsCache );

            this.showTooltip( records );

            L.DomUtil.removeClass(this._container, 'search-load');
          }
          else
          {
            if(this.options.sourceData)
              this._retrieveData = this.options.sourceData;

            else if(this.options.url) //jsonp or ajax
              this._retrieveData = this.options.jsonpParam ? this._recordsFromJsonp : this._recordsFromAjax;

            this._curReq = this._retrieveData.call(this, inputText, function(data) {

              self._recordsCache = self._formatData.call(self, data);

              //TODO refact!
              if(self.options.sourceData)
                records = self._filterData( self._input.value, self._recordsCache );
              else
                records = self._recordsCache;

              self.showTooltip( records );

              L.DomUtil.removeClass(self._container, 'search-load');
            });
          }
        },

        _handleAutoresize: function() {
          var maxWidth;

          if (this._input.style.maxWidth !== this._map._container.offsetWidth) {
            maxWidth = this._map._container.clientWidth;

            // other side margin + padding + width border + width search-button + width search-cancel
            maxWidth -= 10 + 20 + 1 + 30 + 22;

            this._input.style.maxWidth = maxWidth.toString() + 'px';
          }

          if (this.options.autoResize && (this._container.offsetWidth + 20 < this._map._container.offsetWidth)) {
            this._input.size = this._input.value.length < this._inputMinSize ? this._inputMinSize : this._input.value.length;
          }
        },

        _handleArrowSelect: function(velocity) {

          var searchTips = this._tooltip.hasChildNodes() ? this._tooltip.childNodes : [];

          for (i=0; i<searchTips.length; i++)
            L.DomUtil.removeClass(searchTips[i], 'search-tip-select');

          if ((velocity == 1 ) && (this._tooltip.currentSelection >= (searchTips.length - 1))) {// If at end of list.
            L.DomUtil.addClass(searchTips[this._tooltip.currentSelection], 'search-tip-select');
          }
          else if ((velocity == -1 ) && (this._tooltip.currentSelection <= 0)) { // Going back up to the search box.
            this._tooltip.currentSelection = -1;
          }
          else if (this._tooltip.style.display != 'none') {
            this._tooltip.currentSelection += velocity;

            L.DomUtil.addClass(searchTips[this._tooltip.currentSelection], 'search-tip-select');

            this._input.value = searchTips[this._tooltip.currentSelection]._text;

            // scroll:
            var tipOffsetTop = searchTips[this._tooltip.currentSelection].offsetTop;

            if (tipOffsetTop + searchTips[this._tooltip.currentSelection].clientHeight >= this._tooltip.scrollTop + this._tooltip.clientHeight) {
              this._tooltip.scrollTop = tipOffsetTop - this._tooltip.clientHeight + searchTips[this._tooltip.currentSelection].clientHeight;
            }
            else if (tipOffsetTop <= this._tooltip.scrollTop) {
              this._tooltip.scrollTop = tipOffsetTop;
            }
          }
        },

        _handleSubmit: function() { //button and tooltip click and enter submit

          this._hideAutoType();

          this.hideAlert();
          this._hideTooltip();

          if(this._input.style.display == 'none') //on first click show _input only
            this.expand();
          else
          {
            if(this._input.value === '')  //hide _input only
              this.collapse();
            else
            {
              var loc = this._getLocation(this._input.value);

              if(loc===false)
                this.showAlert();
              else
              {
                this.showLocation(loc, this._input.value);
                this.fire('search:locationfound', {
                  latlng: loc,
                  text: this._input.value,
                  layer: loc.layer ? loc.layer : null
                });
              }
            }
          }
        },

        _getLocation: function(key) { //extract latlng from _recordsCache

          if( this._recordsCache.hasOwnProperty(key) )
            return this._recordsCache[key];//then after use .loc attribute
          else
            return false;
        },

        _defaultMoveToLocation: function(latlng, title, map) {
          if(this.options.zoom)
            this._map.setView(latlng, this.options.zoom);
          else
            this._map.panTo(latlng);
        },

        showLocation: function(latlng, title) { //set location on map from _recordsCache
          var self = this;

          self._map.once('moveend zoomend', function(e) {

            if(self._markerSearch) {
              self._markerSearch.addTo(self._map).setLatLng(latlng);
            }

          });

          self._moveToLocation(latlng, title, self._map);
          //FIXME autoCollapse option hide self._markerSearch before visualized!!
          if(self.options.autoCollapse)
            self.collapse();

          return self;
        }
      });

      L.Control.Search.Marker = L.Marker.extend({

        includes: L.version[0]==='1' ? L.Evented.prototype : L.Mixin.Events,

        options: {
          icon: new L.Icon.Default(),
          animate: true,
          circle: {
            radius: 10,
            weight: 3,
            color: '#e03',
            stroke: true,
            fill: false
          }
        },

        initialize: function (latlng, options) {
          L.setOptions(this, options);

          if(options.icon === true)
            options.icon = new L.Icon.Default();

          L.Marker.prototype.initialize.call(this, latlng, options);

          if( L.Control.Search.prototype._isObject(this.options.circle) )
            this._circleLoc = new L.CircleMarker(latlng, this.options.circle);
        },

        onAdd: function (map) {
          L.Marker.prototype.onAdd.call(this, map);
          if(this._circleLoc) {
            map.addLayer(this._circleLoc);
            if(this.options.animate)
              this.animate();
          }
        },

        onRemove: function (map) {
          L.Marker.prototype.onRemove.call(this, map);
          if(this._circleLoc)
            map.removeLayer(this._circleLoc);
        },

        setLatLng: function (latlng) {
          L.Marker.prototype.setLatLng.call(this, latlng);
          if(this._circleLoc)
            this._circleLoc.setLatLng(latlng);
          return this;
        },

        _initIcon: function () {
          if(this.options.icon)
            L.Marker.prototype._initIcon.call(this);
        },

        _removeIcon: function () {
          if(this.options.icon)
            L.Marker.prototype._removeIcon.call(this);
        },

        animate: function() {
          //TODO refact animate() more smooth! like this: http://goo.gl/DDlRs
          if(this._circleLoc)
          {
            var circle = this._circleLoc,
                    tInt = 200, //time interval
                    ss = 5, //frames
                    mr = parseInt(circle._radius/ss),
                    oldrad = this.options.circle.radius,
                    newrad = circle._radius * 2,
                    acc = 0;

            circle._timerAnimLoc = setInterval(function() {
              acc += 0.5;
              mr += acc;  //adding acceleration
              newrad -= mr;

              circle.setRadius(newrad);

              if(newrad<oldrad)
              {
                clearInterval(circle._timerAnimLoc);
                circle.setRadius(oldrad);//reset radius
                //if(typeof afterAnimCall == 'function')
                //afterAnimCall();
                //TODO use create event 'animateEnd' in L.Control.Search.Marker
              }
            }, tInt);
          }

          return this;
        }
      });

      L.Map.addInitHook(function () {
        if (this.options.searchControl) {
          this.searchControl = L.control.search(this.options.searchControl);
          this.addControl(this.searchControl);
        }
      });

      L.control.search = function (options) {
        return new L.Control.Search(options);
      };

      return L.Control.Search;

    });
  </script>

  <script src="https://api.tiles.mapbox.com/mapbox.js/plugins/leaflet-markercluster/v0.4.0/leaflet.markercluster.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.markercluster/1.5.0/leaflet.markercluster.js"></script>


  <script src="https://elfalem.github.io/Leaflet.curve/src/leaflet.curve.js"></script>

  <script async defer src="https://apis.google.com/js/api.js"
          onload="this.onload=function(){};handleClientLoad()"
          onreadystatechange="if (this.readyState === 'complete') this.onload()">
  </script>
</head>

<body>
<div id='map'></div>

<div id="map_sidebar" class="sidebar">
  <a href="javascript:void(0)" class="closebtn" onclick="closeNav()">&times;</a>
  <div id = "nav_info"></div>

</div>

</body>
<script>

  var config = {
    "afpLogo": '"https://images.squarespace-cdn.com/content/5db70e83fc0a966cf4cc42ea/1615901170132-RGK6BNXIHQBXWTSRJC7W"',
    "circleMarker": '"https://images.squarespace-cdn.com/content/5db70e83fc0a966cf4cc42ea/1622486359541-RBZP9D3LUPCQ3BW05XYF"'
  }

  // Add layers for each category
  var Agr = L.layerGroup();
  var Arts = L.layerGroup();
  var Cap = L.layerGroup();
  var Comm = L.layerGroup();
  var Con = L.layerGroup();
  var Dem = L.layerGroup();
  var Dev = L.layerGroup();
  var Div = L.layerGroup();
  var Econ = L.layerGroup();
  var Edu = L.layerGroup();
  var Emer = L.layerGroup();
  var Env = L.layerGroup();
  var Faith = L.layerGroup();
  var Gen = L.layerGroup();
  var Hea = L.layerGroup();
  var HRights = L.layerGroup();
  var HAid = L.layerGroup();
  var MJ = L.layerGroup();
  var MN = L.layerGroup();
  var MH = L.layerGroup();
  var Net = L.layerGroup();
  var Peace = L.layerGroup();
  var Phil = L.layerGroup();
  var Pol = L.layerGroup();
  var Rec = L.layerGroup();
  var Res = L.layerGroup();
  var Rule = L.layerGroup();
  var Sci = L.layerGroup();
  var Soc = L.layerGroup();
  var US = L.layerGroup();
  var You = L.layerGroup();
  var Oth = L.layerGroup();

  // Mapping of layer groups to checkbox names
  var checkboxes = {
    "Agriculture / Natural Resource Management / Food Security": Agr,
    "Arts": Arts,
    "Capacity Building": Cap,
    "Community Development and Engagement / Education": Comm,
    "Conflict Prevention / Management & Resolution": Con,
    "Democracy & Governance": Dem,
    "Development": Dev,
    "Diversity / Equity / Inclusion": Div,
    "Economic Development & Policy": Econ,
    "Education": Edu,
    "Emergency / Disaster Response": Emer,
    "Environment / Climate Justice / Conservation / Wildlife": Env,
    "Faith-based / Interreligious Action": Faith,
    "Gender Equality / Women": Gen,
    "Health": Hea,
    "Human Rights": HRights,
    "Humanitarian Aid": HAid,
    "Media & Journalism": MJ,
    "Mediation & Negotiation": MN,
    "Mental Health & Trauma Informed Care": MH,
    "Networks": Net,
    "Peacebuilding": Peace,
    "Philanthropy": Phil,
    "Policy & Advocacy": Pol,
    "Reconciliation": Rec,
    "Research & Evaluation": Res,
    "Rule of Law": Rule,
    "Science / Technology / Digital Acceleration": Sci,
    "Social Justice": Soc,
    "US Peacebuilding": US,
    "Youth": You,
    "Other": Oth,
  };

  // Store values in checkboxes, because they are not accessible when the checkbox window is closed.
  var checkboxes_values = {
    "Agriculture / Natural Resource Management / Food Security": false,
    "Arts": false,
    "Capacity Building": false,
    "Community Development and Engagement / Education": false,
    "Conflict Prevention / Management & Resolution": false,
    "Democracy & Governance": false,
    "Development": false,
    "Diversity / Equity / Inclusion": false,
    "Economic Development & Policy": false,
    "Education": false,
    "Emergency / Disaster Response": false,
    "Environment / Climate Justice / Conservation / Wildlife": false,
    "Faith-based / Interreligious Action": false,
    "Gender Equality / Women": false,
    "Health": false,
    "Human Rights": false,
    "Humanitarian Aid": false,
    "Media & Journalism": false,
    "Mediation & Negotiation": false,
    "Mental Health & Trauma Informed Care": false,
    "Networks": false,
    "Peacebuilding": false,
    "Philanthropy": false,
    "Policy & Advocacy": false,
    "Reconciliation": false,
    "Research & Evaluation": false,
    "Rule of Law": false,
    "Science / Technology / Digital Acceleration": false,
    "Social Justice": false,
    "US Peacebuilding": false,
    "Youth": false,
    "Other": false,
  };

  // Populate late with organizations pulled from the spreadsheet
  var afpOrgs = [];

  // Hold all markers in a layer and then make more layers to hold subsets of markers
  var all_markers = L.featureGroup();

  // Hold filtered layers of markers
  var marker_layer = L.featureGroup();

  // Current active organization layer of interest to the user
  var active = L.layerGroup();

  // Create a map in the "map" div, set the view to a given place and zoom
  var map = L.map("map", { renderWorldCopies: false, minZoom: 2 }).setView(
          [0, 0],
          2
  );
  map.setMaxBounds([
    [100, -200],
    [-75, 240],
  ]);
  map.zoomControl.setPosition("topright");

  var boxes = "<div class = leaflet-control-layers id = 'checkboxes'>";
  L.Control.Checkboxes = L.Control.extend({
    onAdd: function (_) {
      var div = L.DomUtil.create("div", "box_control");
      L.DomEvent.disableClickPropagation(div);
      div.setAttribute("id", "box_control");
      for (const [k, v] of Object.entries(checkboxes)) {
        boxes += '<input id="' + k + '" type="checkbox">' + k + " </input><br/>";
      }
      boxes += '</div>';
      div.innerHTML = "<div class=t id ='checkboxes'><button type=button>Filter</button></div>";
      return div;
    },
    onRemove: function (map) {
      // Nothing to do here
    },
  });

  box_control = function (opts) {
    return new L.Control.Checkboxes(opts);
  };

  // Show the checkbox control window
  function showBoxControl() {
    var div = document.getElementById("box_control");
    let map_div = document.getElementById("map");
    let map_width = map_div.offsetWidth;
    let map_height = map_div.offsetHeight;
    div.innerHTML = '<form>' + boxes + '</form>';
    div.style.height = map_height-200;
    div.style.width = map_width-10;
    for (const [k, v] of Object.entries(checkboxes)) {
      document.getElementById(k).addEventListener(
              "click",
              () => {
                handleBox(k);
              },
              false
      );
      //set boxes which have a value of true in the storage variable to be checked
      if (checkboxes_values[k]) {
        document.getElementById(k).checked = true;
      }
    }
  }

  // Hide the checkbox control window
  function hideBoxControl() {
    var div = document.getElementById("box_control");
    div.innerHTML = "<div class=t id ='checkboxes'><button type=button>Filter</button></div>";
  }
  box_control({ position: "topright" }).addTo(map);

  // Close filter tab on click outside of box
  document.addEventListener('click', function(e) {
    var target = e.target;
    if(e.path[1].className === 't') {
      showBoxControl();
    }
    else if(target.id !== 'checkboxes' && target["type"] !== "checkbox") hideBoxControl();
  }, false);


  // add the event handler
  function handleBox(category) {
    //get the box we're handling and set its corresponding value in the values object
    element = document.getElementById(category);
    checkboxes_values[category] = element.checked;
    if (element.checked) {
      //if we are checking the box
      //clear the map and add all the layers that are checked
      marker_layer.clearLayers();
      for (const [k, v] of Object.entries(checkboxes_values)) {
        if (v) marker_layer.addLayer(checkboxes[k]);
      }
    } else {
      //if we are unchecking the box
      //check if we're unchecking the last box
      var no_boxes_checked = true;
      for (const [k, v] of Object.entries(checkboxes_values)) {
        if (v) {
          no_boxes_checked = false;
          break;
        }
      }
      //if we aren't, just remove the layer corresponding to the box
      if (!no_boxes_checked) {
        marker_layer.removeLayer(checkboxes[category]);
        //since some orgs have more than one category, add back the ones
        //that were deleted because they overlapped
        for (const [k, v] of Object.entries(checkboxes)) {
          if (document.getElementById(k).checked) {
            marker_layer.addLayer(v);
          }
        }
      }
      //if we are, show all markers
      else {
        marker_layer.addLayer(all_markers);
      }
    }
  }

  // Style how we want the map to look
  L.tileLayer(
          "https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}.png",
          { noWrap: true }
  ).addTo(map);

  // Put data from our Google Sheets into an interpretable format
  function organizeData(data) {
    let toRet = {};

    let entries = data;

    for (var i = 1; i < entries.length; i++) {
      const entry = entries[i];

      const keys = Object.keys(entry); //used to loop over this object

      var orgName = "";
      keys.forEach((key, index) => {
                //store new org titles as keys
                if (key === "Organization Name") {
                  orgName = entry[key];
                  toRet[orgName] = {};
                }
                //store org data in the toRet value object corresponding to its title
                else if (toRet[orgName] !== undefined) {
                  toRet[orgName][key] = entry[key];
                }
              }
      );
    }

    return toRet;
  }

  // Create a map legend and add it to the upper right corner of our map
  var legend = L.control({ position: "topright" });
  legend.onAdd = function (_) {
    var div = L.DomUtil.create("div", "info legend");
    //representing that the AfP logo markers represent headquarters
    div.innerHTML +=
            "<div style='background-color:white;'><img src =" +
            config.afpLogo +
            '", style="width:30px;height:30px;">Headquarters</div>';

    div.innerHTML +=
            "<div style='background-color:white;'><img src =" + config.circleMarker + "style='width:30px;height:30px;'>Field Office</div>";
    return div;
  };
  legend.addTo(map);

  // Icon that will appear for all organizations
  var afpIcon = new L.divIcon({
    html: '<div id="container" class="main-icon-footer "><img src =' + config.afpLogo + '", style="width:30px;height:30px;"><div>',
    className: "AfPicon",
    iconAnchor: [20, 20],
    iconSize: [30, 30],
  });

  // Add organizations to layer groups based on their categories
  function setOrgsInCategory(m, currentOrg) {
    try{
      var orgCat = currentOrg[columnIndexMapping["Categorization (Clean)"]].split(",");
      orgCat.forEach((org) => {
        checkboxes[org].addLayer(m);
      });
    }
    catch(e){
      console.log(e);
    }
  }

  // Create a HTMLElement including org name, logo and blurb
  function createPopUp(name, currentOrg) {
    var customPopup = '<div class = "org_name">' + name + "</div>";
    if (currentOrg[columnIndexMapping["Image URL"]] !== undefined) {
      url = "'" + currentOrg[columnIndexMapping["Image URL"]] + "'";
      customPopup += '<img class = "org_img" src=' + url + "width='80%'/>";
    }
    if (currentOrg[columnIndexMapping["Description"]] !== undefined) {
      customPopup += '<div class = "org_desc">' + currentOrg[columnIndexMapping["Description"]] + "</div>";
    }
    if (currentOrg[columnIndexMapping["URL"]] !== undefined) {
      customPopup +=
              '<div class = "org_url"> Website link: <a target="_blank" href=' +
              currentOrg[columnIndexMapping["URL"]] +
              ">" +
              currentOrg[columnIndexMapping["URL"]] +
              "</a></div>";
    }
    return customPopup;
  }

  // Function to show the sidebar when an organization is clicked
  async function openNav(key, value) {
    await closeNav();

    var viewportWidth = window.innerWidth || document.documentElement.clientWidth;
    if(viewportWidth > 640) {
      document.getElementById("map_sidebar").style.width = "25%";
    }
    else {
      document.getElementById("map_sidebar").style.width = "60%";
    }
    document.getElementById("nav_info").innerHTML = createPopUp(key, value);
  }

  // Close the sidebar
  const closeNav = async () => {
    document.getElementById("map_sidebar").style.width = "0";
    active.clearLayers();
  };

  // Connect to related organizations
  const drawConnections = async (name, currentOrg) => {
    try{
      // Get the list of places where an organization is active
      var placesActive = currentOrg[columnIndexMapping['Active In']].split(', ');

      if (currentOrg[columnIndexMapping["Lat/Lon"]] !== undefined) {
        // Encapsulate the origin marker's latitude and longitude
        var originLatLon = currentOrg[columnIndexMapping["Lat/Lon"]];
        var comma = originLatLon.indexOf(",");
        var lat = originLatLon.slice(1, comma);
        var lon = originLatLon.slice(comma + 1, originLatLon.length - 1);

        var listOfMarkers = [];
        listOfMarkers.push(L.circleMarker([lat, lon]));

        // Iterate through all countries where an organization is active
        // and plot the corresponding latitudes and longitudes
        for (let i = 0; i < placesActive.length; i++) {

          // Get the latitude and longitude of the corresponding country
          var latLon = [iso[placesActive[i]][0][0], iso[placesActive[i]][0][1]];

          // Create a line to connect the new point and the origin point
          polyLinePathOptions = {
            dashArray: "7",
            opacity: 0.7,
            weight: 1.5,
            color: "#279989",
          };
          const polyline = L.polyline([[lat, lon], latLon], polyLinePathOptions);
          active.addLayer(polyline);

          // Create marker where the connection is made
          const m = L.circleMarker(latLon, {radius: 6, color: "#6eceb2"});
          m.bindTooltip(iso[placesActive[i]][1]);
          active.addLayer(m);

          // We want to fit to the bound of the markers, so make sure to add this new marker
          listOfMarkers.push(m);
        }

        // Display the new active points and the corresponding connections
        active.addTo(map);

        // Fit to the bounds of the marker list
        var group = new L.featureGroup(listOfMarkers);
        map.fitBounds(group.getBounds().pad(0.1));
      }
    }
    catch(e){
      console.log(e);
    }
  }

  // Create the map with markers and controls
  const createMap = (sheet) =>
  {
    for(count = 0; count < sheet.length; count++){
      var currentOrg = sheet[count];
      if (currentOrg !== undefined && currentOrg[columnIndexMapping["Lat/Lon"]]!== undefined) {
        var latlon = currentOrg[columnIndexMapping["Lat/Lon"]];
        var comma = latlon.indexOf(",");
        var lat = latlon.slice(1, comma);
        var lon = latlon.slice(comma + 1, latlon.length - 1);
        var currentOrgName = currentOrg[columnIndexMapping["Organization Name"]];

        const m = L.marker([lat, lon], {icon: afpIcon});
        m.currentOrgName = currentOrgName;
        m.currentOrg = currentOrg;

        // Handle all mouse events

        // Create a tooltip with just the organizations
        m.bindTooltip(currentOrgName);

        // Open the sidebar here for the organization we clicked and adjust the map accordingly
        m.on('click', function(_){
          openNav(m.currentOrgName, m.currentOrg);
          drawConnections(m.currentOrgName, m.currentOrg);
        });

        setOrgsInCategory(m, currentOrg);

        // Add this new marker to the feature group or all markers
        all_markers.addLayer(m);
        marker_layer.addLayer(m);
      }
    }

    marker_layer.addTo(map);
  };


  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  // Dictionary mapping iso codes to lat/lng and names of countries
  let iso = {}

  // Map of column names to column index in google sheet
  var columnIndexMapping = {
    "Organization Name" : 0,
    "Logo" : 1,
    "URL" : 2,
    "Address" : 3,
    "Country" : 4,
    "Global North / Global South" : 5,
    "# of Employees Cleaned": 6,
    "Funding Structure Clean" : 7,
    "Categorization (Clean)" : 8,
    "Region" : 9,
    "Active In" : 10,
    "Lat/Lon" : 11,
    "Descriptions" : 12,
    "Image URL" : 13
  }

  //This method replaces the big hardcoded dictionary of iso codes
  function makeApiCallForISOCodes(){
    //get specific spreadsheet in specific range
    var params = {
      spreadsheetId : '1Z2PSCbO6AKlpV8_wby-Lm0Ww9tpa6NY8R6kRtHSkLLM',
      range : 'A2:C251'
    }

    //make request to sheets api
    var request = gapi.client.sheets.spreadsheets.values.get(params);
    request.then(function(response) {
      var range = response.result;
      //if we actually got data back
      if (range.values.length > 0) {
        //for every organization in the spreadsheet
        for (i = 0; i < range.values.length; i++) {
          //get entire row of data
          var row = range.values[i];
          //three letter iso code
          var code = row[0];
          //lat,lon data
          var latlon = row[1];
          //split latlon to get individual values
          var comma = latlon.indexOf(",");
          var lat = latlon.slice(0,comma);
          var lon = latlon.slice(comma + 1, latlon.length);
          //full name of country
          var name = row[2];
          //construct array to hold lat/long values
          var latLonArr = [lat, lon];
          //put data into map to access when drawing green dashes
          iso[code] = [latLonArr,name];
        }
      }
    }, function(reason) {
      console.error('error: ' + reason.result.error.message);
    });
  }

  //array to hold information for all AFP organizations
  let DataFromSheets = [];

  function makeApiCallForMemberData() {
    //specify ID of spreadsheet, range of data we want from that spreadsheet
    var params = {
      spreadsheetId : '1Vfzjkiib0ZfwszfKoRdedp9QzXMopccnd2OZIwzqxvs',
      range : 'B2:O136',
    };
    //get all the data
    var request = gapi.client.sheets.spreadsheets.values.get(params);
    request.then(function(response) {
      var range = response.result;
      if (range.values.length > 0) {
        //for every organization in the spreadsheet
        for (i = 0; i < range.values.length; i++) {
          var row = range.values[i];
          //push the entire row of information
          DataFromSheets.push(row);
        }
        //call function to parse strings, drop dots
        createMap(DataFromSheets);
      }
    }, function(reason) {
      console.error('error: ' + reason.result.error.message);
    });
  }

  async function initClient() {
    //get client id and api key from local text file
    var data = await fetch('KEY_ID.txt').then(response => response.text());
    var lines = data.split('\n');
    var CLIENT_ID = lines[1];
    var API_KEY = lines[0];

    //scope defined as read-only: data can't be modified in sheet
    var SCOPE = "https://www.googleapis.com/auth/spreadsheets.readonly";
    var DISCOVERY_DOCS = ['https://sheets.googleapis.com/$discovery/rest?version=v4'];
    //initiate the client, pass in parameters
    gapi.client.init({
      'apiKey': API_KEY,
      'clientId': CLIENT_ID,
      'scope': SCOPE,
      'discoveryDocs': DISCOVERY_DOCS,
    }).then(function() {
      //make sheets api call to get data for all AFP organizations
      makeApiCallForMemberData();
      //make sheets api call to get ISO codes for all countries
      makeApiCallForISOCodes();
    });
  }
  //called when page is loaded
  function handleClientLoad(){
    gapi.load('client', initClient);
  }

</script>