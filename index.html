<head>
  <link href="https://fonts.googleapis.com/css?family=Cardo:400,700|Oswald" rel="stylesheet">
  
  <meta charset="utf-8">
  
  <script>
    document.write('<base href="' + document.location + '" />');
  </script>
  <style>
    /* Add your styles here */  
  .marker-cluster { 
    background-clip: padding-box; 
    border-radius: 20px;  
    } 
  .marker-cluster div { 
    width: 30px;  
    height: 30px; 
    margin-left: 5px; 
    margin-top: 5px;  
    
    text-align: center; 
    border-radius: 15px;  
    font: 12px "Helvetica Neue", Arial, Helvetica, sans-serif;  
    } 
  .marker-cluster span {  
    line-height: 30px;  
    } 
  .marker-cluster-small { 
    background-color: rgba(10, 200, 235, .6); 
    } 
  .marker-cluster-small div { 
    background-color: rgba(0, 181, 226, .6);  
    } 
  .marker-cluster-medium {  
    background-color: rgba(10, 125, 205, 0.6);  
    } 
  .marker-cluster-medium div {  
    background-color: rgba(0, 119, 200, 0.6); 
    } 
    
  .marker-cluster-large { 
    background-color: rgba(10, 105, 165, 0.6);  
    } 
  .marker-cluster-large div { 
    background-color: rgba(0, 98, 155, 0.6);  
    } 
    
  * { 
      box-sizing: border-box; 
    margin: 0;  
    padding: 0; 
    font-size: inherit; 
  } 
    
  /** Setting the default font sizes */ 
  html {  
    width: 100%;  
    height: 100%; 
    background-color: #555566;  
  } 
    
  body {  
    width: 100%;  
    height: 100%; 
    cursor: auto; 
    background-color: #555566;  
  } 
    
  #map {  
    height: 100%;
    width: 100%; 
    position: absolute;
    top: 0; 
    right: 0; 
    left: 0;  
    bottom: 0;  
    z-index: 0;
  }   
    
  .AfPicon {  
    border-radius:300%; 
    background-attachment: fixed; 
    background-position: top left;  
    position: absolute; 
    border-width: 30px;
  } 
    
  .main-icon-footer { 
    position: absolute; 
    display: flex;  
    justify-content: center;  
    align-items: center;  
    width: 40px;  
    height: 40px; 
    border-radius: 100%;  
    background: white;  
    border: 1px #ffffff solid;  
    box-shadow: 0px 2px 0px 0px rgb(204, 186, 186); 
  } 
    
  .t{ 
    padding-top: 1px; 
    width: 30px;  
    height: 30px; 
    text-align: right;  
  } 
    
  .leaflet-control-layers { 
    margin: 10px auto;  
    text-align: left; 
    overflow: auto;
  } 
    
    
  /* The sidebar menu */  
  .sidebar {  
    height: 100%; /* 100% Full-height */  
    width: 0; /* 0 width - change this with JavaScript */ 
    position: absolute; /* Stay in place */ 
    z-index: 1000; /* Stay on top */  
    top: 0; 
    left: 0;  
    background-color:rgba(255, 255, 255, 0.75); 
    overflow-x: hidden; /* Disable horizontal scroll */
    word-wrap: normal;  
    padding-top: 50px;  
    transition: 0.5s; /* 0.5 second transition effect to slide in the sidebar */  
  }   
    
  /* Position and style the close button (top right corner) */  
  .sidebar .closebtn {  
    position: absolute; 
    top: 0; 
    right: 20px;  
    font-size: 36px;  
    color: #2a2a2a; 
    text-decoration: none;  
  } 
    
  .sidebar .closebtn:hover{ 
    color: #a9a9a9; 
  } 
    
  /* Style page content - use this if you want to push the page content to the right when you open the side navigation */ 
  #main { 
    transition: margin-left .5s; /* If you want a transition effect */  
    padding: 20px;  
  } 
    
  .org_name { 
    font-family: 'Oswald', sans-serif;  
    text-transform: uppercase;  
    font-size: 1.5vw; 
    text-align: center; 
    margin: 10px 20px 10px 20px;  
  } 
    
  .org_img {  
    display: block; 
    margin-left: auto;  
    margin-right: auto; 
  } 
    
  .org_desc { 
    font-family: 'Cardo', serif;  
    font-size: 1.25vw;  
    color: #464646; 
    margin: 10px 20px 10px 20px;  
  } 
    
  .org_url {  
    font-family: 'Cardo', serif;  
    font-size: 1.25vw;  
    color: #464646; 
    margin: 20px 20px 10px 20px;    
  } 
  
  .org_url > a {
    font-size: 1.25vw;
  }
  
  .leaflet-control-search.search-exp {/*expanded*/  
    background: #fff; 
    border: 2px solid rgba(0,0,0,0.2);  
    background-clip: padding-box;   
  } 
  .leaflet-control-search .search-input { 
    display:block;  
    float:left; 
    background: #fff; 
    border:1px solid #666;  
    border-radius:2px;  
    height:22px;  
    padding:0 20px 0 2px; 
    margin:4px 0 4px 4px; 
  } 
  .leaflet-control-search.search-load .search-input { 
    background: url('https://raw.githubusercontent.com/stefanocudini/leaflet-search/master/images/loader.gif') no-repeat center right #fff; 
  } 
  .leaflet-control-search.search-load .search-cancel {  
    visibility:hidden;  
  } 
  .leaflet-control-search .search-cancel {  
    display:block;  
    width:22px; 
    height:22px;  
    position:absolute;  
    right:28px; 
    margin:6px 0; 
    background: url('https://raw.githubusercontent.com/stefanocudini/leaflet-search/master/images/search-icon.png') no-repeat 0 -46px;  
    text-decoration:none; 
    filter: alpha(opacity=80);  
    opacity: 0.8;     
  } 
  .leaflet-control-search .search-cancel:hover {  
    filter: alpha(opacity=100); 
    opacity: 1; 
  } 
  .leaflet-control-search .search-cancel span { 
    display:none;/* comment for cancel button imageless */  
    font-size:18px; 
    line-height:20px; 
    color:#ccc; 
    font-weight:bold; 
  } 
  .leaflet-control-search .search-cancel:hover span { 
    color:#aaa; 
  } 
  .leaflet-control-search .search-button {  
    display:block;  
    float:right;  
    width:30px; 
    height:30px;    
    background: url('https://raw.githubusercontent.com/stefanocudini/leaflet-search/master/images/search-icon.png') no-repeat 4px 4px #fff; 
    border-right-width: 400px;  
    border-radius:400px;  
    border-color:red; 
  } 
  .leaflet-control-search .search-button:hover {  
    background: url('https://raw.githubusercontent.com/stefanocudini/leaflet-search/master/images/search-icon.png') no-repeat 4px -20px #fafafa;  
  } 
  .leaflet-control-search .search-tooltip { 
    position:absolute;  
    top:100%; 
    left:0; 
    float:left; 
    list-style: none; 
    padding-left: 0;  
    min-width:120px;  
    max-height:122px; 
    box-shadow: 1px 1px 6px rgba(0,0,0,0.4);  
    background-color: rgba(0, 0, 0, 0.25);  
    z-index:1010; 
    overflow-y:auto;  
    overflow-x:hidden;  
    cursor: pointer;  
  } 
  .leaflet-control-search .search-tip { 
    margin:2px; 
    padding:2px 4px;  
    display:block;  
    color:black;  
    background: #eee; 
    border-radius:.25em;  
    text-decoration:none;   
    white-space:nowrap; 
  } 
  .leaflet-control-search .search-button:hover {  
    background-color: #f4f4f4;  
  } 
  .leaflet-control-search .search-tip-select, 
  .leaflet-control-search .search-tip:hover { 
    background-color: #fff; 
  } 
  .leaflet-control-search .search-alert { 
    cursor:pointer; 
    clear:both; 
    font-size:.75em;  
    margin-bottom:5px;  
    padding:0 .25em;  
    color:#e00; 
    font-weight:bold; 
    border-radius:.25em;
  }
  .leaflet-top{
    background-color:rgba(0, 98, 155, 0.4);
    border-radius: 12px;
    margin: 5px;
  }
  .control_button{
    background-color:#ffffff;
    border-radius: 12px;
    width: 35px;
    height: 34px;
    z-index: 314159;
  }

  .legend{
    position:relative;
    left:5px;
  }
    </style>
  
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.0.3/leaflet.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.0.3/leaflet.js"></script>
  <script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.0.7/angular.min.js"></script>
  
  
  <script type="text/javascript">
   /*
    Name          Data passed        Description
  
    Managed Events:
     search:locationfound {latlng, title, layer} fired after moved and show markerLocation
     search:expanded    {}             fired after control was expanded
     search:collapsed   {}             fired after control was collapsed
      search:cancel     {}             fired after cancel button clicked
  
    Public methods:
     setLayer()       L.LayerGroup()         set layer search at runtime
     showAlert()            'Text message'         show alert message
     searchText()     'Text searched'        search text by external code
  */
  
  //TODO implement can do research on multiple sources layers and remote    
  //TODO history: false,    //show latest searches in tooltip   
  //FIXME option condition problem {autoCollapse: true, markerLocation: true} not show location
  //FIXME option condition problem {autoCollapse: false }
  //
  //TODO here insert function  search inputText FIRST in _recordsCache keys and if not find results.. 
  //  run one of callbacks search(sourceData,jsonpUrl or options.layer) and run this.showTooltip
  //
  //TODO change structure of _recordsCache
  //  like this: _recordsCache = {"text-key1": {loc:[lat,lng], ..other attributes.. }, {"text-key2": {loc:[lat,lng]}...}, ...}
  //  in this mode every record can have a free structure of attributes, only 'loc' is required
  //TODO important optimization!!! always append data in this._recordsCache
  //  now _recordsCache content is emptied and replaced with new data founded
  //  always appending data on _recordsCache give the possibility of caching ajax, jsonp and layersearch!
  //
  //TODO here insert function  search inputText FIRST in _recordsCache keys and if not find results.. 
  //  run one of callbacks search(sourceData,jsonpUrl or options.layer) and run this.showTooltip
  //
  //TODO change structure of _recordsCache
  //  like this: _recordsCache = {"text-key1": {loc:[lat,lng], ..other attributes.. }, {"text-key2": {loc:[lat,lng]}...}, ...}
  //  in this way every record can have a free structure of attributes, only 'loc' is required
  
  (function (factory) {
      if(typeof define === 'function' && define.amd) {
      //AMD
          define(['leaflet'], factory);
      } else if(typeof module !== 'undefined') {
      // Node/CommonJS
          module.exports = factory(require('leaflet'));
      } else {
      // Browser globals
          if(typeof window.L === 'undefined')
              throw 'Leaflet must be loaded first';
          factory(window.L);
      }
  })(function (L) {
  
  
  L.Control.Search = L.Control.extend({
    
    includes: L.version[0]==='1' ? L.Evented.prototype : L.Mixin.Events,
  
    options: {
      url: '',            //url for search by ajax request, ex: "search.php?q={s}". Can be function to returns string for dynamic parameter setting
      layer: null,          //layer where search markers(is a L.LayerGroup)       
      sourceData: null,       //function to fill _recordsCache, passed searching text by first param and callback in second       
      //TODO implements uniq option 'sourceData' to recognizes source type: url,array,callback or layer       
      jsonpParam: null,       //jsonp param name for search by jsonp service, ex: "callback"
      propertyLoc: 'loc',       //field for remapping location, using array: ['latname','lonname'] for select double fields(ex. ['lat','lon'] ) support dotted format: 'prop.subprop.title'
      propertyName: 'org_title',      //property in marker.options(or feature.properties for vector layer) trough filter elements in layer,
      formatData: null,       //callback for reformat all data from source to indexed data object
      filterData: null,       //callback for filtering data from text searched, params: textSearch, allRecords
      moveToLocation: null,     //callback run on location found, params: latlng, title, map
      buildTip: null,         //function to return row tip html node(or html string), receive text tooltip in first param
      container: '',          //container id to insert Search Control   
      zoom: null,           //default zoom level for move to location
      minLength: 1,         //minimal text length for autocomplete
      initial: true,          //search elements only by initial text
      casesensitive: false,     //search elements in case sensitive text
      autoType: true,         //complete input with first suggested result and select this filled-in text.
      delayType: 400,         //delay while typing for show tooltip
      tooltipLimit: -1,       //limit max results to show in tooltip. -1 for no limit, 0 for no results
      tipAutoSubmit: true,      //auto map panTo when click on tooltip
      firstTipSubmit: false,      //auto select first result con enter click
      autoResize: true,       //autoresize on input change
      collapsed: true,        //collapse search control at startup
      autoCollapse: false,      //collapse search control after submit(on button or on tips if enabled tipAutoSubmit)
      autoCollapseTime: 1200,     //delay for autoclosing alert and collapse after blur
      textErr: 'Location not found',  //error message
      textCancel: 'Cancel',       //title in cancel button    
      textPlaceholder: 'Search...',   //placeholder value     
      hideMarkerOnCollapse: false,    //remove circle and marker on search control collapsed    
      position: 'topleft',    
      marker: {           //custom L.Marker or false for hide
        icon: false,        //custom L.Icon for maker location or false for hide
        animate: true,        //animate a circle over location found
        circle: {         //draw a circle in location found
          radius: 10,
          weight: 3,
          color: '#e03',
          stroke: true,
          fill: false
        }
      }
    },
  
    _getPath: function(obj, prop) {
      var parts = prop.split('.'),
        last = parts.pop(),
        len = parts.length,
        cur = parts[0],
        i = 1;
  
      if(len > 0)
        while((obj = obj[cur]) && i < len)
          cur = parts[i++];
  
      if(obj)
        return obj[last];
    },
  
    _isObject: function(obj) {
      return Object.prototype.toString.call(obj) === "[object Object]";
    },
  
    initialize: function(options) {
      L.Util.setOptions(this, options || {});
      this._inputMinSize = this.options.textPlaceholder ? this.options.textPlaceholder.length : 10;
      this._layer = this.options.layer || new L.LayerGroup();
      this._filterData = this.options.filterData || this._defaultFilterData;
      this._formatData = this.options.formatData || this._defaultFormatData;
      this._moveToLocation = this.options.moveToLocation || this._defaultMoveToLocation;
      this._autoTypeTmp = this.options.autoType;  //useful for disable autoType temporarily in delete/backspace keydown
      this._countertips = 0;    //number of tips items
      this._recordsCache = {};  //key,value table! to store locations! format: key,latlng
      this._curReq = null;
    },
  
    onAdd: function (map) {
      this._map = map;
      this._container = L.DomUtil.create('div', 'leaflet-control-search');
      this._input = this._createInput(this.options.textPlaceholder, 'search-input');
      this._tooltip = this._createTooltip('search-tooltip');
      this._cancel = this._createCancel(this.options.textCancel, 'search-cancel');
      this._button = this._createButton(this.options.textPlaceholder, 'search-button');
      this._alert = this._createAlert('search-alert');
  
      if(this.options.collapsed===false)
        this.expand(this.options.collapsed);
  
      if(this.options.marker) {
        
        if(this.options.marker instanceof L.Marker || this.options.marker instanceof L.CircleMarker)
          this._markerSearch = this.options.marker;
  
        else if(this._isObject(this.options.marker))
          this._markerSearch = new L.Control.Search.Marker([0,0], this.options.marker);
  
        this._markerSearch._isMarkerSearch = true;
      }
  
      this.setLayer( this._layer );
      //Figure this out later!
      //L.DomEvent.disableClickPropagation(this);
  
      map.on({
        //    'layeradd': this._onLayerAddRemove,
        //    'layerremove': this._onLayerAddRemove
        'resize': this._handleAutoresize
        }, this);
      return this._container;
    },
    addTo: function (map) {
  
      if(this.options.container) {
        this._container = this.onAdd(map);
        this._wrapper = L.DomUtil.get(this.options.container);
        this._wrapper.style.position = 'relative';
        this._wrapper.appendChild(this._container);
      }
      else
        L.Control.prototype.addTo.call(this, map);
  
      return this;
    },
  
    onRemove: function(map) {
      this._recordsCache = {};
      // map.off({
      //    'layeradd': this._onLayerAddRemove,
      //    'layerremove': this._onLayerAddRemove
      //  }, this);
      map.off({
        //    'layeradd': this._onLayerAddRemove,
        //    'layerremove': this._onLayerAddRemove
        'resize': this._handleAutoresize
        }, this);
    },
  
    // _onLayerAddRemove: function(e) {
    //  //without this, run setLayer also for each Markers!! to optimize!
    //  if(e.layer instanceof L.LayerGroup)
    //    if( L.stamp(e.layer) != L.stamp(this._layer) )
    //      this.setLayer(e.layer);
    // },
  
    setLayer: function(layer) { //set search layer at runtime
      //this.options.layer = layer; //setting this, run only this._recordsFromLayer()
      this._layer = layer;
      this._layer.addTo(this._map);
      return this;
    },
    
    showAlert: function(text) {
      var self = this;
      text = text || this.options.textErr;
      this._alert.style.display = 'block';
      this._alert.innerHTML = text;
      clearTimeout(this.timerAlert);
      
      this.timerAlert = setTimeout(function() {
        self.hideAlert();
      },this.options.autoCollapseTime);
      return this;
    },
    
    hideAlert: function() {
      this._alert.style.display = 'none';
      return this;
    },
      
    cancel: function() {
      this._input.value = '';
      this._handleKeypress({ keyCode: 8 });//simulate backspace keypress
      this._input.size = this._inputMinSize;
      this._input.focus();
      this._cancel.style.display = 'none';
      this._hideTooltip();
      this.fire('search:cancel');
      return this;
    },
    
    expand: function(toggle) {
      toggle = typeof toggle === 'boolean' ? toggle : true;
      this._input.style.display = 'block';
      L.DomUtil.addClass(this._container, 'search-exp');
      if ( toggle !== false ) {
        this._input.focus();
        this._map.on('dragstart click', this.collapse, this);
      }
      this.fire('search:expanded');
      return this;  
    },
  
    collapse: function() {
      this._hideTooltip();
      this.cancel();
      this._alert.style.display = 'none';
      this._input.blur();
      if(this.options.collapsed)
      {
        this._input.style.display = 'none';
        this._cancel.style.display = 'none';      
        L.DomUtil.removeClass(this._container, 'search-exp');   
        if (this.options.hideMarkerOnCollapse) {
          this._map.removeLayer(this._markerSearch);
        }
        this._map.off('dragstart click', this.collapse, this);
      }
      this.fire('search:collapsed');
      return this;
    },
    
    collapseDelayed: function() { //collapse after delay, used on_input blur
      var self = this;
      if (!this.options.autoCollapse) return this;
      clearTimeout(this.timerCollapse);
      this.timerCollapse = setTimeout(function() {
        self.collapse();
      }, this.options.autoCollapseTime);
      return this;    
    },
  
    collapseDelayedStop: function() {
      clearTimeout(this.timerCollapse);
      return this;    
    },
  
    ////start DOM creations
    _createAlert: function(className) {
      var alert = L.DomUtil.create('div', className, this._container);
      alert.style.display = 'none';
  
      L.DomEvent
        .on(alert, 'click', L.DomEvent.stop, this)
        .on(alert, 'click', this.hideAlert, this);
  
      return alert;
    },
  
    _createInput: function (text, className) {
      var self = this;
      var label = L.DomUtil.create('label', className, this._container);
      var input = L.DomUtil.create('input', className, this._container);
      input.type = 'text';
      input.size = this._inputMinSize;
      input.value = '';
      input.autocomplete = 'off';
      input.autocorrect = 'off';
      input.autocapitalize = 'off';
      input.placeholder = text;
      input.style.display = 'none';
      input.role = 'search';
      input.id = input.role + input.type + input.size;
      
      label.htmlFor = input.id;
      label.style.display = 'none';
      label.value = text;
  
      L.DomEvent
        .disableClickPropagation(input)
        .on(input, 'keyup', this._handleKeypress, this)
        .on(input, 'paste', function(e) {
          setTimeout(function(e) {
            self._handleKeypress(e);
          },10,e);
        }, this)
        .on(input, 'blur', this.collapseDelayed, this)
        .on(input, 'focus', this.collapseDelayedStop, this);
      
      return input;
    },
  
    _createCancel: function (title, className) {
      var cancel = L.DomUtil.create('a', className, this._container);
      cancel.href = '#';
      cancel.title = title;
      cancel.style.display = 'none';
      cancel.innerHTML = "<span>&otimes;</span>";//imageless(see css)
  
      L.DomEvent
        .on(cancel, 'click', L.DomEvent.stop, this)
        .on(cancel, 'click', this.cancel, this);
  
      return cancel;
    },
    
    _createButton: function (title, className) {
      var button = L.DomUtil.create('a', className, this._container);
      button.href = '#';
      button.title = title;
  
      L.DomEvent
        .on(button, 'click', L.DomEvent.stop, this)
        .on(button, 'click', this._handleSubmit, this)      
        .on(button, 'focus', this.collapseDelayedStop, this)
        .on(button, 'blur', this.collapseDelayed, this);
  
      return button;
    },
  
    _createTooltip: function(className) {
      var self = this;    
      var tool = L.DomUtil.create('ul', className, this._container);
      tool.style.display = 'none';
      L.DomEvent
        .disableClickPropagation(tool)
        .on(tool, 'blur', this.collapseDelayed, this)
        .on(tool, 'mousewheel', function(e) {
          self.collapseDelayedStop();
          L.DomEvent.stopPropagation(e);//disable zoom map
        }, this)
        .on(tool, 'mouseover', function(e) {
          self.collapseDelayedStop();
        }, this);
      return tool;
    },
  
    _createTip: function(text, val) {//val is object in recordCache, usually is Latlng
      var tip;
      
      if(this.options.buildTip)
      {
        tip = this.options.buildTip.call(this, text, val); //custom tip node or html string
        if(typeof tip === 'string')
        {
          var tmpNode = L.DomUtil.create('div');
          tmpNode.innerHTML = tip;
          tip = tmpNode.firstChild;
        }
      }
      else
      {
        tip = L.DomUtil.create('li', '');
        tip.innerHTML = text;
      }
      
      L.DomUtil.addClass(tip, 'search-tip');
      tip._text = text; //value replaced in this._input and used by _autoType
  
      if(this.options.tipAutoSubmit)
        L.DomEvent
          .disableClickPropagation(tip)   
          .on(tip, 'click', L.DomEvent.stop, this)
          .on(tip, 'click', function(e) {
            this._input.value = text;
            this._handleAutoresize();
            this._input.focus();
            this._hideTooltip();  
            this._handleSubmit();
          }, this);
  
      return tip;
    },
  
    //////end DOM creations
  
    _getUrl: function(text) {
      return (typeof this.options.url === 'function') ? this.options.url(text) : this.options.url;
    },
  
    _defaultFilterData: function(text, records) {
    
      var I, icase, regSearch, frecords = {};
  
      text = text.replace(/[.*+?^${}()|[\]\\]/g, '');  //sanitize remove all special characters
      if(text==='')
        return [];
  
      I = this.options.initial ? '^' : '';  //search only initial text
      icase = !this.options.casesensitive ? 'i' : undefined;
  
      regSearch = new RegExp(I + text, icase);
  
      //TODO use .filter or .map
      for(var key in records) {
        if( regSearch.test(key) )
          frecords[key]= records[key];
      }
      
      return frecords;
    },
  
    showTooltip: function(records) {
      
  
      this._countertips = 0;
      this._tooltip.innerHTML = '';
      this._tooltip.currentSelection = -1;  //inizialized for _handleArrowSelect()
  
      if(this.options.tooltipLimit)
      {
        for(var key in records)//fill tooltip
        {
          if(this._countertips === this.options.tooltipLimit)
            break;
          
          this._countertips++;
  
          this._tooltip.appendChild( this._createTip(key, records[key]) );
        }
      }
      
      if(this._countertips > 0)
      {
        this._tooltip.style.display = 'block';
        
        if(this._autoTypeTmp)
          this._autoType();
  
        this._autoTypeTmp = this.options.autoType;//reset default value
      }
      else
        this._hideTooltip();
  
      this._tooltip.scrollTop = 0;
  
      return this._countertips;
    },
  
    _hideTooltip: function() {
      this._tooltip.style.display = 'none';
      this._tooltip.innerHTML = '';
      return 0;
    },
  
    _defaultFormatData: function(json) {  //default callback for format data to indexed data
      var self = this,
        propName = this.options.propertyName,
        propLoc = this.options.propertyLoc,
        i, jsonret = {};
  
      if( L.Util.isArray(propLoc) )
        for(i in json)
          jsonret[ self._getPath(json[i],propName) ]= L.latLng( json[i][ propLoc[0] ], json[i][ propLoc[1] ] );
      else
        for(i in json)
          jsonret[ self._getPath(json[i],propName) ]= L.latLng( self._getPath(json[i],propLoc) );
      //TODO throw new Error("propertyName '"+propName+"' not found in JSON data");
      return jsonret;
    },
  
    _recordsFromJsonp: function(text, callAfter) {  //extract searched records from remote jsonp service
      L.Control.Search.callJsonp = callAfter;
      var script = L.DomUtil.create('script','leaflet-search-jsonp', document.getElementsByTagName('body')[0] ),      
        url = L.Util.template(this._getUrl(text)+'&'+this.options.jsonpParam+'=L.Control.Search.callJsonp', {s: text}); //parsing url
        //rnd = '&_='+Math.floor(Math.random()*10000);
        //TODO add rnd param or randomize callback name! in recordsFromJsonp
      script.type = 'text/javascript';
      script.src = url;
      return { abort: function() { script.parentNode.removeChild(script); } };
    },
  
    _recordsFromAjax: function(text, callAfter) { //Ajax request
      if (window.XMLHttpRequest === undefined) {
        window.XMLHttpRequest = function() {
          try { return new ActiveXObject("Microsoft.XMLHTTP.6.0"); }
          catch  (e1) {
            try { return new ActiveXObject("Microsoft.XMLHTTP.3.0"); }
            catch (e2) { throw new Error("XMLHttpRequest is not supported"); }
          }
        };
      }
      var IE8or9 = ( L.Browser.ie && !window.atob && document.querySelector ),
        request = IE8or9 ? new XDomainRequest() : new XMLHttpRequest(),
        url = L.Util.template(this._getUrl(text), {s: text});
  
      //rnd = '&_='+Math.floor(Math.random()*10000);
      //TODO add rnd param or randomize callback name! in recordsFromAjax     
      
      request.open("GET", url);
      
  
      request.onload = function() {
        callAfter( JSON.parse(request.responseText) );
      };
      request.onreadystatechange = function() {
          if(request.readyState === 4 && request.status === 200) {
            this.onload();
          }
      };
  
      request.send();
      return request;   
    },
  
    _searchInLayer: function(layer, retRecords, propName) {
      var self = this, loc;
  
      if(layer instanceof L.Control.Search.Marker) return;
  
      if(layer instanceof L.Marker || layer instanceof L.CircleMarker)
      {
        if(self._getPath(layer.options,propName))
        {
          loc = layer.getLatLng();
          loc.layer = layer;
          retRecords[ self._getPath(layer.options,propName) ] = loc;
        }
        else if(self._getPath(layer.feature.properties,propName))
        {
          loc = layer.getLatLng();
          loc.layer = layer;
          retRecords[ self._getPath(layer.feature.properties,propName) ] = loc;
        }
        else {
          //throw new Error("propertyName '"+propName+"' not found in marker"); 
          console.warn("propertyName '"+propName+"' not found in marker"); 
        }
      }
      else if(layer instanceof L.Path || layer instanceof L.Polyline || layer instanceof L.Polygon)
      {
        if(self._getPath(layer.options,propName))
        {
          loc = layer.getBounds().getCenter();
          loc.layer = layer;
          retRecords[ self._getPath(layer.options,propName) ] = loc;
        }
        else if(self._getPath(layer.feature.properties,propName))
        {
          loc = layer.getBounds().getCenter();
          loc.layer = layer;
          retRecords[ self._getPath(layer.feature.properties,propName) ] = loc;
        }
        else {
          //throw new Error("propertyName '"+propName+"' not found in shape"); 
          console.warn("propertyName '"+propName+"' not found in shape"); 
        }
      }
      else if(layer.hasOwnProperty('feature'))//GeoJSON
      {
        if(layer.feature.properties.hasOwnProperty(propName))
        {
          if(layer.getLatLng && typeof layer.getLatLng === 'function') {
            loc = layer.getLatLng();
            loc.layer = layer;      
            retRecords[ layer.feature.properties[propName] ] = loc;
          } else if(layer.getBounds && typeof layer.getBounds === 'function') {
            loc = layer.getBounds().getCenter();
            loc.layer = layer;      
            retRecords[ layer.feature.properties[propName] ] = loc;
          } else {
            console.warn("Unknown type of Layer");
          }
        }
        else {
          //throw new Error("propertyName '"+propName+"' not found in feature");
          console.warn("propertyName '"+propName+"' not found in feature"); 
        }
      }
      else if(layer instanceof L.LayerGroup)
      {
        layer.eachLayer(function (layer) {
          self._searchInLayer(layer, retRecords, propName);
        });
      }
    },
    
    _recordsFromLayer: function() { //return table: key,value from layer
      var self = this,
        retRecords = {},
        propName = this.options.propertyName;
      
      this._layer.eachLayer(function (layer) {
        console.log(layer)
        self._searchInLayer(layer, retRecords, propName);
      });
      
      return retRecords;
    },
    
    _autoType: function() {
      
      //TODO implements autype without selection(useful for mobile device)
      
      var start = this._input.value.length,
        firstRecord = this._tooltip.firstChild ? this._tooltip.firstChild._text : '',
        end = firstRecord.length;
  
      if (firstRecord.indexOf(this._input.value) === 0) { // If prefix match
        this._input.value = firstRecord;
        this._handleAutoresize();
  
        if (this._input.createTextRange) {
          var selRange = this._input.createTextRange();
          selRange.collapse(true);
          selRange.moveStart('character', start);
          selRange.moveEnd('character', end);
          selRange.select();
        }
        else if(this._input.setSelectionRange) {
          this._input.setSelectionRange(start, end);
        }
        else if(this._input.selectionStart) {
          this._input.selectionStart = start;
          this._input.selectionEnd = end;
        }
      }
    },
  
    _hideAutoType: function() { // deselect text:
  
      var sel;
      if ((sel = this._input.selection) && sel.empty) {
        sel.empty();
      }
      else if (this._input.createTextRange) {
        sel = this._input.createTextRange();
        sel.collapse(true);
        var end = this._input.value.length;
        sel.moveStart('character', end);
        sel.moveEnd('character', end);
        sel.select();
      }
      else {
        if (this._input.getSelection) {
          this._input.getSelection().removeAllRanges();
        }
        this._input.selectionStart = this._input.selectionEnd;
      }
    },
    
    _handleKeypress: function (e) { //run _input keyup event
      var self = this;
  
      switch(e.keyCode)
      {
        case 27://Esc
          this.collapse();
        break;
        case 13://Enter
          if(this._countertips == 1 || (this.options.firstTipSubmit && this._countertips > 0)) {
                  if(this._tooltip.currentSelection == -1) {
              this._handleArrowSelect(1);
                  }
          }
          this._handleSubmit(); //do search
        break;
        case 38://Up
          this._handleArrowSelect(-1);
        break;
        case 40://Down
          this._handleArrowSelect(1);
        break;
        case 37://Left
        case 39://Right
        case 16://Shift
        case 17://Ctrl
        case 35://End
        case 36://Home
        break;
        case  8://Backspace
        case 45://Insert
        case 46://Delete
          this._autoTypeTmp = false;//disable temporarily autoType
        default://All keys
          if(this._input.value.length)
            this._cancel.style.display = 'block';
          else
            this._cancel.style.display = 'none';
  
          if(this._input.value.length >= this.options.minLength)
          {
            clearTimeout(this.timerKeypress); //cancel last search request while type in        
            this.timerKeypress = setTimeout(function() {  //delay before request, for limit jsonp/ajax request
  
              self._fillRecordsCache();
            
            }, this.options.delayType);
          }
          else
            this._hideTooltip();
      }
  
      this._handleAutoresize();
    },
  
    searchText: function(text) {
      var code = text.charCodeAt(text.length);
  
      this._input.value = text;
  
      this._input.style.display = 'block';
      L.DomUtil.addClass(this._container, 'search-exp');
  
      this._autoTypeTmp = false;
  
      this._handleKeypress({keyCode: code});
    },
    
    _fillRecordsCache: function() {
  
      var self = this,
        inputText = this._input.value, records;
  
      if(this._curReq && this._curReq.abort)
        this._curReq.abort();
      //abort previous requests
  
      L.DomUtil.addClass(this._container, 'search-load'); 
  
      if(this._layer)
      {
        //TODO _recordsFromLayer must return array of objects, formatted from _formatData
        this._recordsCache = this._recordsFromLayer();
        
        records = this._filterData( this._input.value, this._recordsCache );
  
        this.showTooltip( records );
  
        L.DomUtil.removeClass(this._container, 'search-load');
      }
      else
      {
        if(this.options.sourceData)
          this._retrieveData = this.options.sourceData;
  
        else if(this.options.url) //jsonp or ajax
          this._retrieveData = this.options.jsonpParam ? this._recordsFromJsonp : this._recordsFromAjax;
  
        this._curReq = this._retrieveData.call(this, inputText, function(data) {
          
          self._recordsCache = self._formatData.call(self, data);
  
          //TODO refact!
          if(self.options.sourceData)
            records = self._filterData( self._input.value, self._recordsCache );
          else
            records = self._recordsCache;
  
          self.showTooltip( records );
   
          L.DomUtil.removeClass(self._container, 'search-load');
        });
      }
    },
    
    _handleAutoresize: function() {
        var maxWidth;
  
      if (this._input.style.maxWidth !== this._map._container.offsetWidth) {
        maxWidth = this._map._container.clientWidth;
  
        // other side margin + padding + width border + width search-button + width search-cancel
        maxWidth -= 10 + 20 + 1 + 30 + 22; 
  
        this._input.style.maxWidth = maxWidth.toString() + 'px';
      }
  
      if (this.options.autoResize && (this._container.offsetWidth + 20 < this._map._container.offsetWidth)) {
        this._input.size = this._input.value.length < this._inputMinSize ? this._inputMinSize : this._input.value.length;
      }
    },
  
    _handleArrowSelect: function(velocity) {
    
      var searchTips = this._tooltip.hasChildNodes() ? this._tooltip.childNodes : [];
        
      for (i=0; i<searchTips.length; i++)
        L.DomUtil.removeClass(searchTips[i], 'search-tip-select');
      
      if ((velocity == 1 ) && (this._tooltip.currentSelection >= (searchTips.length - 1))) {// If at end of list.
        L.DomUtil.addClass(searchTips[this._tooltip.currentSelection], 'search-tip-select');
      }
      else if ((velocity == -1 ) && (this._tooltip.currentSelection <= 0)) { // Going back up to the search box.
        this._tooltip.currentSelection = -1;
      }
      else if (this._tooltip.style.display != 'none') {
        this._tooltip.currentSelection += velocity;
        
        L.DomUtil.addClass(searchTips[this._tooltip.currentSelection], 'search-tip-select');
        
        this._input.value = searchTips[this._tooltip.currentSelection]._text;
  
        // scroll:
        var tipOffsetTop = searchTips[this._tooltip.currentSelection].offsetTop;
        
        if (tipOffsetTop + searchTips[this._tooltip.currentSelection].clientHeight >= this._tooltip.scrollTop + this._tooltip.clientHeight) {
          this._tooltip.scrollTop = tipOffsetTop - this._tooltip.clientHeight + searchTips[this._tooltip.currentSelection].clientHeight;
        }
        else if (tipOffsetTop <= this._tooltip.scrollTop) {
          this._tooltip.scrollTop = tipOffsetTop;
        }
      }
    },
  
    _handleSubmit: function() { //button and tooltip click and enter submit
  
      this._hideAutoType();
      
      this.hideAlert();
      this._hideTooltip();
  
      if(this._input.style.display == 'none') //on first click show _input only
        this.expand();
      else
      {
        if(this._input.value === '')  //hide _input only
          this.collapse();
        else
        {
          var loc = this._getLocation(this._input.value);
          
          if(loc===false)
            this.showAlert();
          else
          {
            this.showLocation(loc, this._input.value);
            this.fire('search:locationfound', {
                latlng: loc,
                text: this._input.value,
                layer: loc.layer ? loc.layer : null
              });
          }
        }
      }
    },
  
    _getLocation: function(key) { //extract latlng from _recordsCache
  
      if( this._recordsCache.hasOwnProperty(key) )
        return this._recordsCache[key];//then after use .loc attribute
      else
        return false;
    },
  
    _defaultMoveToLocation: function(latlng, title, map) {
      if(this.options.zoom)
         this._map.setView(latlng, this.options.zoom);
       else
        this._map.panTo(latlng);
    },
  
    showLocation: function(latlng, title) { //set location on map from _recordsCache
      var self = this;
  
      self._map.once('moveend zoomend', function(e) {
  
        if(self._markerSearch) {
          self._markerSearch.addTo(self._map).setLatLng(latlng);
        }
        
      });
  
      self._moveToLocation(latlng, title, self._map);
      //FIXME autoCollapse option hide self._markerSearch before visualized!!
      if(self.options.autoCollapse)
        self.collapse();
  
      return self;
    }
  });
  
  L.Control.Search.Marker = L.Marker.extend({
  
    includes: L.version[0]==='1' ? L.Evented.prototype : L.Mixin.Events,
    
    options: {
      icon: new L.Icon.Default(),
      animate: true,
      circle: {
        radius: 10,
        weight: 3,
        color: '#e03',
        stroke: true,
        fill: false
      }
    },
    
    initialize: function (latlng, options) {
      L.setOptions(this, options);
  
      if(options.icon === true)
        options.icon = new L.Icon.Default();
  
      L.Marker.prototype.initialize.call(this, latlng, options);
      
      if( L.Control.Search.prototype._isObject(this.options.circle) )
        this._circleLoc = new L.CircleMarker(latlng, this.options.circle);
    },
  
    onAdd: function (map) {
      L.Marker.prototype.onAdd.call(this, map);
      if(this._circleLoc) {
        map.addLayer(this._circleLoc);
        if(this.options.animate)
          this.animate();
      }
    },
  
    onRemove: function (map) {
      L.Marker.prototype.onRemove.call(this, map);
      if(this._circleLoc)
        map.removeLayer(this._circleLoc);
    },
    
    setLatLng: function (latlng) {
      L.Marker.prototype.setLatLng.call(this, latlng);
      if(this._circleLoc)
        this._circleLoc.setLatLng(latlng);
      return this;
    },
    
    _initIcon: function () {
      if(this.options.icon)
        L.Marker.prototype._initIcon.call(this);
    },
  
    _removeIcon: function () {
      if(this.options.icon)
        L.Marker.prototype._removeIcon.call(this);
    },
  
    animate: function() {
    //TODO refact animate() more smooth! like this: http://goo.gl/DDlRs
      if(this._circleLoc)
      {
        var circle = this._circleLoc,
          tInt = 200, //time interval
          ss = 5, //frames
          mr = parseInt(circle._radius/ss),
          oldrad = this.options.circle.radius,
          newrad = circle._radius * 2,
          acc = 0;
  
        circle._timerAnimLoc = setInterval(function() {
          acc += 0.5;
          mr += acc;  //adding acceleration
          newrad -= mr;
          
          circle.setRadius(newrad);
  
          if(newrad<oldrad)
          {
            clearInterval(circle._timerAnimLoc);
            circle.setRadius(oldrad);//reset radius
            //if(typeof afterAnimCall == 'function')
              //afterAnimCall();
              //TODO use create event 'animateEnd' in L.Control.Search.Marker 
          }
        }, tInt);
      }
      
      return this;
    }
  });
  
  L.Map.addInitHook(function () {
      if (this.options.searchControl) {
          this.searchControl = L.control.search(this.options.searchControl);
          this.addControl(this.searchControl);
      }
  });
  
  L.control.search = function (options) {
      return new L.Control.Search(options);
  };
  
  return L.Control.Search;
  
  });
  </script>
  
   <script src="https://api.tiles.mapbox.com/mapbox.js/plugins/leaflet-markercluster/v0.4.0/leaflet.markercluster.js"></script>
   <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.markercluster/1.5.0/leaflet.markercluster.js"></script>
  
  
  <script src="https://elfalem.github.io/Leaflet.curve/src/leaflet.curve.js"></script>
  
  <script async defer src="https://apis.google.com/js/api.js"
          onload="this.onload=function(){};handleClientLoad()"
          onreadystatechange="if (this.readyState === 'complete') this.onload()">
  </script>
  </head>
   
  <body>
    <div id='map'></div>
    
    <div id="map_sidebar" class="sidebar">
    <a href="javascript:void(0)" class="closebtn" onclick="closeNav()">&times;</a>
    <div id = "nav_info"></div>
    
    </div>
    
  </body>
  <script>
  
  var config = {
    "afpLogo": '"https://images.squarespace-cdn.com/content/5db70e83fc0a966cf4cc42ea/1615901170132-RGK6BNXIHQBXWTSRJC7W"',
    "circleMarker": '"https://images.squarespace-cdn.com/content/5db70e83fc0a966cf4cc42ea/1622486359541-RBZP9D3LUPCQ3BW05XYF"'
  } 
  
  let afpOrgs = [];
  // create a map in the "map" div, set the view to a given place and zoom
  var map = L.map("map", { renderWorldCopies: false, minZoom: 2 }).setView(
    [0, 0],
    2
  );
  map.setMaxBounds([
    [100, -180],
    [-75, 200],
  ]);
  L.tileLayer(
    "https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}.png",
    { noWrap: false }
  ).addTo(map);
    //dictionary mapping iso codes to lat/lng and names of countries
  let isoCodesDict = {}

  //This method replaces the big hardcoded dictionary of iso codes 
  function makeApiCallForISOCodes(){
    //get specific spreadsheet in specific range
    var params = {
      spreadsheetId : '1Z2PSCbO6AKlpV8_wby-Lm0Ww9tpa6NY8R6kRtHSkLLM',
      range : 'A2:C251'
    }

    //make request to sheets api
    var request = gapi.client.sheets.spreadsheets.values.get(params);
      request.then(function(response) {
        var range = response.result;
        //if we actually got data back
        if (range.values.length > 0) {
          //for every organization in the spreadsheet
          for (i = 0; i < range.values.length; i++) {
            //get entire row of data
            var row = range.values[i];
            //three letter iso code
            var code = row[0];
            //lat,lon data
            var latlon = row[1];
            //split latlon to get individual values
            var comma = latlon.indexOf(",");
            var lat = latlon.slice(0,comma);
            var lon = latlon.slice(comma + 1, latlon.length);
            //full name of country
            var name = row[2];
            //construct array to hold lat/long values
            var latLonArr = [lat,lon];
            //put data into map to access when drawing green dashes
            isoCodesDict[code] = [latLonArr,name];
          }

      } 
      }, function(reason) {
        console.error('error: ' + reason.result.error.message);
      });

  }

  //adds organizations to layer groups based on their categories
  function setOrgsInCategory(category, group) {
    layers = all_markers["_layers"];
    //for (const [key, value] of Object.entries(afpOrgs)) {
    for(count = 0; count < DataFromSheets.length; count++){
      var org = DataFromSheets[count];
      var orgCat = org[columnIndexMapping["Categorization (Clean)"]];
      if (orgCat != undefined) {
        var catList = orgCat.split(",");
        if (layers != undefined && catList.indexOf(category) >= 0) {
          for (const [k, v] of Object.entries(layers)) {
            if (v["options"]["org_title"] === org[columnIndexMapping["Organization Name"]]) {
              group.addLayer(v);
            }
          }
        }
      }
    }
  }

  //map of column names to column index in google sheet 
  var columnIndexMapping = {
    "Organization Name" : 0,
    "Logo" : 1,
    "URL" : 2,
    "Address" : 3,
    "Country" : 4,
    "Global North / Global South" : 5,
    "# of Employees Cleaned": 6,
    "Funding Structure Clean" : 7,
    "Categorization (Clean)" : 8,
    "Region" : 9,
    "Active In" : 10,
    "Lat/Lon" : 11,
    "Descriptions" : 12,
    "Image URL" : 13
  }
    
  //array to hold information for all AFP organizations
  let DataFromSheets = [];
  
  function makeApiCallForMemberData() {
    //specify ID of spreadsheet, range of data we want from that spreadsheet
    var params = {
      spreadsheetId : '1Vfzjkiib0ZfwszfKoRdedp9QzXMopccnd2OZIwzqxvs',
      range : 'B2:O136',
    };
    //get all the data
    var request = gapi.client.sheets.spreadsheets.values.get(params);
      request.then(function(response) {
        var range = response.result;
        if (range.values.length > 0) {
          //for every organization in the spreadsheet
          for (i = 0; i < range.values.length; i++) {
            var row = range.values[i];
            //push the entire row of information
            DataFromSheets.push(row);
          }
          //call function to parse strings, drop dots
          createMap(DataFromSheets);
      } 
      }, function(reason) {
        console.error('error: ' + reason.result.error.message);
      });
  }

  async function initClient() {
    //get client id and api key from local text file
    var data = await fetch('KEY_ID.txt').then(response => response.text());
    var lines = data.split('\n');
    var CLIENT_ID = lines[1];    
    var API_KEY = lines[0];
 
    //scope defined as read-only: data can't be modified in sheet
    var SCOPE = "https://www.googleapis.com/auth/spreadsheets.readonly";
    var DISCOVERY_DOCS = ['https://sheets.googleapis.com/$discovery/rest?version=v4'];
      //initiate the client, pass in parameters
      gapi.client.init({
        'apiKey': API_KEY,
        'clientId': CLIENT_ID,
        'scope': SCOPE,
        'discoveryDocs': DISCOVERY_DOCS,
      }).then(function() {
        //make sheets api call to get data for all AFP organizations
        makeApiCallForMemberData();
        //make sheets api call to get ISO codes for all countries
        makeApiCallForISOCodes();
      });
    }
    //called when page is loaded
    function handleClientLoad(){
      gapi.load('client', initClient);
    }
  
  var all_markers = L.featureGroup();
  //create and color marker clusters based on size
  var marker_layer = L.markerClusterGroup({
    iconCreateFunction: function (cluster) {
      var childCount = cluster.getChildCount();
      var c = " marker-cluster-";
      if (childCount < 10) {
        c += "small";
      } else if (childCount < 50) {
        c += "medium";
      } else {
        c += "large";
      }
  
      return new L.DivIcon({
        html: "<div><span>" + childCount + "</span></div>",
        className: "marker-cluster" + c,
        iconSize: new L.Point(40, 40),
      });
    },
  });
  
  var active = L.layerGroup();
  
  //add legend to map
  var legend = L.control({ position: "topright" });
  
  legend.onAdd = function (map) {
    var div = L.DomUtil.create("div", "info legend");
    //representing that the AfP logo markers represent headquarters
    div.innerHTML +=
      "<div style='background-color:white;'><img src =" +
      config.afpLogo +
      '", style="width:30px;height:30px;">Headquarters</div>';
  
    div.innerHTML +=
      "<div style='background-color:white;'><img src =" + config.circleMarker + "style='width:30px;height:30px;'>Field Office</div>";
    return div;
  };
  
  legend.addTo(map);
  
  //create the map with markers and controls
  function createMap(sheet) {
    
    for(count = 0; count < sheet.length; count++){
      //get lat/long of current organization
      var currentOrg = sheet[count];
      var latlon = currentOrg[columnIndexMapping["Lat/Lon"]];
      var comma = latlon.indexOf(",");
      var lat = latlon.slice(1, comma);
      var lon = latlon.slice(comma + 1, latlon.length - 1);
      //create a marker at given lat/lon for the given organization
      var m = L.marker([lat, lon], { title: "", icon: AfPicon, org_title: currentOrg[0], info: sheet[count] });
      m.bindTooltip(currentOrg[0]).openTooltip();
  
      marker_layer.addLayer(m);
      all_markers.addLayer(m);
    }
    marker_layer.addTo(map);

    for (const [k, v] of Object.entries(checkboxes)) {
      setOrgsInCategory(k, v);
    }

  };
  
  map.zoomControl.setPosition("topright");
  // add the search bar to the map
  var controlSearch = new L.Control.Search({
    position: "topright", // where do you want the search bar?
    layer: marker_layer, // name of the layer
    initial: false,
    zoom: 11, // set zoom to found location when searched
    marker: false,
    textPlaceholder: "Search for an organization...", // placeholder while nothing is searched
  });
  
  map.addControl(controlSearch);
  
  var right_sidebar = document.querySelector(".leaflet-top.leaflet-right");
  var toggle_right_sidebar = document.createElement("button");
  toggle_right_sidebar.style.cssText='position:absolute;top: 5;right:130;';
  toggle_right_sidebar.classList.add('control_button');

  toggle_right_sidebar.onclick = function(){
    if(right_sidebar.style.visibility == 'hidden'){
          right_sidebar.style.visibility = 'visible';
          toggle_right_sidebar.innerHTML=">";
          toggle_right_sidebar.style.cssText='position:absolute;top: 5;right:130;';
        }
    else{
          right_sidebar.style.visibility = 'hidden';
          toggle_right_sidebar.innerHTML="<";
        }
    };
    
  right_sidebar.after(toggle_right_sidebar)
  toggle_right_sidebar.innerHTML=">"



  var AfPicon = new L.divIcon({
    html:
      '<div id="container" class="main-icon-footer "><img src =' +
      config.afpLogo +
      '", style="width:30px;height:30px;"><div>',
    className: "AfPicon",
    iconAnchor: [20, 20],
    iconSize: [30, 30],
  });
  
  function createPopUp(name, info) {
    //Write a function that can create a HTMLElement including org name, logo and blurb
    var customPopup = '<div class = "org_name">' + name + "</div>";
    //modified indexing to use columnIndexMapping
    if (info[columnIndexMapping["Image URL"]] != undefined) {
      url = "'" + info[columnIndexMapping["Image URL"]] + "'";
      customPopup += '<img class = "org_img" src=' + url + "width='80%'/>";
    }
    if (info[columnIndexMapping["Descriptions"]] != undefined) {
      customPopup += '<div class = "org_desc">' + info[columnIndexMapping["Descriptions"]] + "</div>";
    }
    if (info[columnIndexMapping["URL"]] != undefined) {
      customPopup +=
        '<div class = "org_url"> Website link: <a href=' +
        info[columnIndexMapping["URL"]] +
        ">" +
        info[columnIndexMapping["URL"]] +
        "</a></div>";
    }
    return customPopup;
  }
  
  
  //Checkbox filtering
  
  
  //Add layers for each category
  //Agriculture / Natural Resource Management / Food Security
  var Agr = L.layerGroup();
  
  //Arts
  var Arts = L.layerGroup();
  
  //Capacity Building
  var Cap = L.layerGroup();
  
  //Community Development and Engagement / Education
  var Comm = L.layerGroup();
  
  //Conflict Prevention / Management & Resolution
  var Con = L.layerGroup();
  
  //Democracy & Government
  var Dem = L.layerGroup();
  
  //Development
  var Dev = L.layerGroup();
  
  //Diversity / Equity / Inclusion
  var Div = L.layerGroup();
  
  //Economic Development and Policy
  var Econ = L.layerGroup();
  
  //Education
  var Edu = L.layerGroup();
  
  //Emergency / Disaster Response
  var Emer = L.layerGroup();
  
  //Environment / Climate Justice / Conservation / Wildlife
  var Env = L.layerGroup();
  
  //Faith-based / Interreligious Action
  var Faith = L.layerGroup();
  
  //Gender Equality / Women
  var Gen = L.layerGroup();
  
  //Health
  var Hea = L.layerGroup();
  
  //Human Rights
  var HRights = L.layerGroup();
  
  //Humanitarian Aid
  var HAid = L.layerGroup();
  
  //Media & Journalism
  var MJ = L.layerGroup();
  
  //Meditation & Negotiation
  var MN = L.layerGroup();
  
  //Mental Health & Trauma Informed Care
  var MH = L.layerGroup();
  
  //Networks
  var Net = L.layerGroup();
  
  //Peacebuilding
  var Peace = L.layerGroup();
  
  //Philanthropy
  var Phil = L.layerGroup();
  
  //Policy & Advocacy
  var Pol = L.layerGroup();
  
  //Reconciliation
  var Rec = L.layerGroup();
  
  //Research & Evaluation
  var Res = L.layerGroup();
  
  //Rule of Law
  var Rule = L.layerGroup();
  
  //Science / Technology / Digital Accelera
  var Sci = L.layerGroup();
  
  //Social Justice
  var Soc = L.layerGroup();
  
  //US Peacebuilding
  var US = L.layerGroup();
  
  //Youth
  var You = L.layerGroup();
  
  //Other
  var Oth = L.layerGroup();
  
  //Mapping of layer groups to checkbox names
  var checkboxes = {
    "Agriculture / Natural Resource Management / Food Security": Agr,
    "Arts": Arts,
    "Capacity Building": Cap,
    "Community Development and Engagement / Education": Comm,
    "Conflict Prevention / Management & Resolution": Con,
    "Democracy & Governance": Dem,
    "Development": Dev,
    "Diversity / Equity / Inclusion": Div,
    "Economic Development & Policy": Econ,
    "Education": Edu,
    "Emergency / Disaster Response": Emer,
    "Environment / Climate Justice / Conservation / Wildlife": Env,
    "Faith-based / Interreligious Action": Faith,
    "Gender Equality / Women": Gen,
    "Health": Hea,
    "Human Rights": HRights,
    "Humanitarian Aid": HAid,
    "Media & Journalism": MJ,
    "Mediation & Negotiation": MN,
    "Mental Health & Trauma Informed Care": MH,
    "Networks": Net,
    "Peacebuilding": Peace,
    "Philanthropy": Phil,
    "Policy & Advocacy": Pol,
    "Reconciliation": Rec,
    "Research & Evaluation": Res,
    "Rule of Law": Rule,
    "Science / Technology / Digital Acceleration": Sci,
    "Social Justice": Soc,
    "US Peacebuilding": US,
    "Youth": You,
    "Other": Oth,
    //"Clusters": {Agr, Arts, Cap, Comm, Con, Dem, Dev, Div, Econ, Edu, Emer, Env, Faith, Gen, Hea, HRights, HAid, MJ, MN, MH, Net, Peace, Phil, Pol, Rec, Res, Rule, Sci, Soc, US, You, Oth} //debug
  };
  
  boxes = "<div class = leaflet-control-layers id = 'checkboxes'>";
  L.Control.Checkboxes = L.Control.extend({
    onAdd: function (map) {
      var div = L.DomUtil.create("div", "box_control");
      L.DomEvent.disableClickPropagation(div);
      div.setAttribute("id", "box_control");
      for (const [k, v] of Object.entries(checkboxes)) {
        boxes += '<input id="' + k + '" type="checkbox">' + k + " </input><br/>";
      }
      boxes += '</div>';
      div.innerHTML = "<div class=t id ='checkboxes'><button type=button class = \"control_button\" \
        style=\"float:left;margin-bottom:5px;\">Filter</button></div>";
      return div;
    },
    onRemove: function (map) {
      // Nothing to do here
    },
  });
  
  box_control = function (opts) {
    return new L.Control.Checkboxes(opts);
  };
  
  //store values of checkboxes, since they aren't accessible when the checkbox window is closed
  var checkboxes_values = {
    "Agriculture / Natural Resource Management / Food Security": false,
    "Arts": false,
    "Capacity Building": false,
    "Community Development and Engagement / Education": false,
    "Conflict Prevention / Management & Resolution": false,
    "Democracy & Governance": false,
    "Development": false,
    "Diversity / Equity / Inclusion": false,
    "Economic Development & Policy": false,
    "Education": false,
    "Emergency / Disaster Response": false,
    "Environment / Climate Justice / Conservation / Wildlife": false,
    "Faith-based / Interreligious Action": false,
    "Gender Equality / Women": false,
    "Health": false,
    "Human Rights": false,
    "Humanitarian Aid": false,
    "Media & Journalism": false,
    "Mediation & Negotiation": false,
    "Mental Health & Trauma Informed Care": false,
    "Networks": false,
    "Peacebuilding": false,
    "Philanthropy": false,
    "Policy & Advocacy": false,
    "Reconciliation": false,
    "Research & Evaluation": false,
    "Rule of Law": false,
    "Science / Technology / Digital Acceleration": false,
    "Social Justice": false,
    "US Peacebuilding": false,
    "Youth": false,
    "Other": false,
  };
  
  //functions to show and hide the checkbox control window
  function showBoxControl() {
    var div = document.getElementById("box_control");
    let map_div = document.getElementById("map");
    let map_width = map_div.offsetWidth;
    let map_height = map_div.offsetHeight;
    div.innerHTML = '<form>' + boxes + '</form>';
    div.style.height = map_height;
    div.style.width = map_width-1500;
    for (const [k, v] of Object.entries(checkboxes)) {
      document.getElementById(k).addEventListener(
        "click",
        () => {
          handleBox(k);
        },
        false
      );
      //set boxes which have a value of true in the storage variable to be checked
      if (checkboxes_values[k]) {
        document.getElementById(k).checked = true;
      }
    }
    toggle_right_sidebar.style.cssText='position:absolute;top: 5;right:450;';
  }
  
  function hideBoxControl() {
    var div = document.getElementById("box_control");
    div.innerHTML = "<div class=t id ='checkboxes'><button type=button class = \"control_button\" \
        style=\"float:left;margin-bottom:5px;\">Filter</button></div>";
    div.style.cssText='.leaflet-top'
    toggle_right_sidebar.style.cssText='position:absolute;top: 5;right:130;';
  }
  box_control({ position: "topright" }).addTo(map);
  
  // Filtration closes on mouse click outside of the box
  document.addEventListener('click', function(e) {
    e = e || window.event;
    var target = e.target;
    if(e.path[1].className == 't') {
      showBoxControl();
    }
    else if(target.id !== 'checkboxes' && target["type"] !== "checkbox") hideBoxControl();
  }, false);
  
  
  // add the event handler
  function handleBox(category) {
    //get the box we're handling and set its corresponding value in the values object
    element = document.getElementById(category);
    checkboxes_values[category] = element.checked;
    if (element.checked) {
      //if we are checking the box
      //clear the map and add all the layers that are checked
      marker_layer.clearLayers();
      for (const [k, v] of Object.entries(checkboxes_values)) {
        if (v) marker_layer.addLayer(checkboxes[k]);
      }
    } else {
      //if we are unchecking the box
      //check if we're unchecking the last box
      var no_boxes_checked = true;
      for (const [k, v] of Object.entries(checkboxes_values)) {
        if (v) {
          no_boxes_checked = false;
          break;
        }
      }
      //if we aren't, just remove the layer corresponding to the box
      if (!no_boxes_checked) {
        marker_layer.removeLayer(checkboxes[category]);
        //since some orgs have more than one category, add back the ones
        //that were deleted because they overlapped
        for (const [k, v] of Object.entries(checkboxes)) {
          if (document.getElementById(k).checked) {
            marker_layer.addLayer(v);
          }
        }
      }
      //if we are, show all markers
      else {
        marker_layer.addLayer(all_markers);
      }
    }
  }
  
  //attempt to make tooltips on clusters
  let markersInCluster = [];
  let titlesInCluster = [];
  marker_layer.on("clustermouseover", function (e) {
    if (typeof e.layer["options"]["org_title"] == "undefined") {
      markersInCluster = [];
      titlesInCluster = [];
      getMarkersRecursively(e.layer);
      for (const v of markersInCluster) {
        titlesInCluster.push(v["options"]["org_title"]);
      }
      e.layer.bindTooltip(titlesInCluster.slice(0, 3).join(", ")).openTooltip();
    }
  });
  
  //change this if it starts impacting performance, fine for now
  function getMarkersRecursively(e) {
    if (e == []) {
      return;
    } else {
      markersInCluster.push.apply(markersInCluster, e["_markers"]);
      for (const v of e["_childClusters"]) {
        getMarkersRecursively(v);
      }
    }
  }
  
  //math for making the paths from organizations to their field offices curved
  function bezierCurve(latLngOne, latLngTwo, pathOptions) {
    var latlngs = [];
  
    var latlng1 = latLngOne,
      latlng2 = latLngTwo;
  
    var offsetX = latlng2[1] - latlng1[1],
      offsetY = latlng2[0] - latlng1[0];
  
    var r = Math.sqrt(Math.pow(offsetX, 2) + Math.pow(offsetY, 2)),
      theta = Math.atan2(offsetY, offsetX);
  
    var thetaOffset = 3.14 / 10;
    if (offsetX < 0) thetaOffset *= -1;
  
    var r2 = r / 2 / Math.cos(thetaOffset),
      theta2 = theta + thetaOffset;
  
    var midpointX = r2 * Math.cos(theta2) + latlng1[1],
      midpointY = r2 * Math.sin(theta2) + latlng1[0];
  
    var midpointLatLng = [midpointY, midpointX];
  
    latlngs.push(latlng1, midpointLatLng, latlng2);
  
    var curvedPath = L.curve(
      ["M", latlng1, "Q", midpointLatLng, latlng2],
      pathOptions
    );
  
    return curvedPath;
  }
  
  
  //function to show the sidebar when an organization is clicked
  async function openNav(clicked_marker) {
    await closeNav();
    
    var viewportWidth = window.innerWidth || document.documentElement.clientWidth;
    if(viewportWidth > 640) {
      document.getElementById("map_sidebar").style.width = "25%";
    }
    else {
      document.getElementById("map_sidebar").style.width = "60%";
    }
    document.getElementById("nav_info").innerHTML = createPopUp(
      clicked_marker["options"]["org_title"], clicked_marker["options"]["info"]
    );
    /*document.getElementById("nav_info").innerHTML = createPopUp(
      clicked_marker["options"]["org_title"],
      afpOrgs[clicked_marker["options"]["org_title"]]
    );*/
    var marker = clicked_marker;
    if (
      marker["options"]["info"][columnIndexMapping["Active In"]] != "" &&
      marker["options"]["info"][columnIndexMapping["Active In"]] != undefined
    ) {
      var regs = marker["options"]["info"][columnIndexMapping["Active In"]].split(", ");
      var regLatLong;
      var LLtoLL;
      var subRegionCurve;
      for (const [k, code] of Object.entries(regs)) {
        //access lat long corresponding to iso code and make a marker
  
        regLatLong = [isoCodesDict[code][0][0], isoCodesDict[code][0][1]];
  
        markerLatLong = [marker.getLatLng().lat, marker.getLatLng().lng];
  
        LLtoLL = [markerLatLong, regLatLong];
  
        polyLinePathOptions = {
          dashArray: "7",
          opacity: 0.7,
          weight: 1.5,
          color: "#279989",
        };
  
        subRegionCurve = bezierCurve(
          markerLatLong,
          regLatLong,
          polyLinePathOptions
        );
        m = L.circleMarker(regLatLong, { radius: 6, color: "#6eceb2" });
        m.bindTooltip(isoCodesDict[code][1]).openTooltip();
        active.addLayer(m);
        active.addLayer(subRegionCurve);
      }
      map.setZoom(2);
      active.addTo(map);
    }
  }
  
  //hide the sidebar
  const closeNav = async () => {
    document.getElementById("map_sidebar").style.width = "0";
    active.clearLayers();
    return;
  };
  
  marker_layer.on("click", function (event) {
    var clicked_marker = event.layer;
    openNav(clicked_marker);
  });
  
</script>
  